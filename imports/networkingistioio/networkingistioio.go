// networkingistioio
package networkingistioio

import (
	_jsii_ "github.com/aws/jsii-runtime-go/runtime"
	_init_ "github.com/coopnorge/cdk8slibrary/imports/networkingistioio/jsii"

	"github.com/aws/constructs-go/constructs/v10"
	"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2"
	"github.com/coopnorge/cdk8slibrary/imports/networkingistioio/internal"
)

type DestinationRule interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for DestinationRule
type jsiiProxy_DestinationRule struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_DestinationRule) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRule) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRule) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRule) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRule) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRule) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRule) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "DestinationRule" API object.
func NewDestinationRule(scope constructs.Construct, id *string, props *DestinationRuleProps) DestinationRule {
	_init_.Initialize()

	j := jsiiProxy_DestinationRule{}

	_jsii_.Create(
		"networkingistioio.DestinationRule",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "DestinationRule" API object.
func NewDestinationRule_Override(d DestinationRule, scope constructs.Construct, id *string, props *DestinationRuleProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.DestinationRule",
		[]interface{}{scope, id, props},
		d,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func DestinationRule_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.DestinationRule",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "DestinationRule".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func DestinationRule_Manifest(props *DestinationRuleProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.DestinationRule",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func DestinationRule_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.DestinationRule",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func DestinationRule_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.DestinationRule",
		"GVK",
		&returns,
	)
	return returns
}

func (d *jsiiProxy_DestinationRule) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		d,
		"addDependency",
		args,
	)
}

func (d *jsiiProxy_DestinationRule) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		d,
		"addJsonPatch",
		args,
	)
}

func (d *jsiiProxy_DestinationRule) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		d,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (d *jsiiProxy_DestinationRule) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		d,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type DestinationRuleProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting load balancing, outlier detection, etc.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
	Spec *DestinationRuleSpec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting load balancing, outlier detection, etc.
//
// See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
type DestinationRuleSpec struct {
	// A list of namespaces to which this destination rule is exported.
	ExportTo *[]*string `field:"optional" json:"exportTo" yaml:"exportTo"`
	// The name of a service from the service registry.
	Host             *string                              `field:"optional" json:"host" yaml:"host"`
	Subsets          *[]*DestinationRuleSpecSubsets       `field:"optional" json:"subsets" yaml:"subsets"`
	TrafficPolicy    *DestinationRuleSpecTrafficPolicy    `field:"optional" json:"trafficPolicy" yaml:"trafficPolicy"`
	WorkloadSelector *DestinationRuleSpecWorkloadSelector `field:"optional" json:"workloadSelector" yaml:"workloadSelector"`
}

type DestinationRuleSpecSubsets struct {
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
	// Name of the subset.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Traffic policies that apply to this subset.
	TrafficPolicy *DestinationRuleSpecSubsetsTrafficPolicy `field:"optional" json:"trafficPolicy" yaml:"trafficPolicy"`
}

// Traffic policies that apply to this subset.
type DestinationRuleSpecSubsetsTrafficPolicy struct {
	ConnectionPool *DestinationRuleSpecSubsetsTrafficPolicyConnectionPool `field:"optional" json:"connectionPool" yaml:"connectionPool"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer     *DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer     `field:"optional" json:"loadBalancer" yaml:"loadBalancer"`
	OutlierDetection *DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection `field:"optional" json:"outlierDetection" yaml:"outlierDetection"`
	// Traffic policies specific to individual ports.
	PortLevelSettings *[]*DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings `field:"optional" json:"portLevelSettings" yaml:"portLevelSettings"`
	// TLS related settings for connections to the upstream service.
	Tls    *DestinationRuleSpecSubsetsTrafficPolicyTls    `field:"optional" json:"tls" yaml:"tls"`
	Tunnel *DestinationRuleSpecSubsetsTrafficPolicyTunnel `field:"optional" json:"tunnel" yaml:"tunnel"`
}

type DestinationRuleSpecSubsetsTrafficPolicyConnectionPool struct {
	// HTTP connection pool settings.
	Http *DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp `field:"optional" json:"http" yaml:"http"`
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp `field:"optional" json:"tcp" yaml:"tcp"`
}

// HTTP connection pool settings.
type DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp struct {
	// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
	H2UpgradePolicy         DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy `field:"optional" json:"h2UpgradePolicy" yaml:"h2UpgradePolicy"`
	Http1MaxPendingRequests *float64                                                                 `field:"optional" json:"http1MaxPendingRequests" yaml:"http1MaxPendingRequests"`
	// Maximum number of active requests to a destination.
	Http2MaxRequests *float64 `field:"optional" json:"http2MaxRequests" yaml:"http2MaxRequests"`
	// The idle timeout for upstream connection pool connections.
	IdleTimeout *string `field:"optional" json:"idleTimeout" yaml:"idleTimeout"`
	// Maximum number of requests per connection to a backend.
	MaxRequestsPerConnection *float64 `field:"optional" json:"maxRequestsPerConnection" yaml:"maxRequestsPerConnection"`
	MaxRetries               *float64 `field:"optional" json:"maxRetries" yaml:"maxRetries"`
	// If set to true, client protocol will be preserved while initiating connection to backend.
	UseClientProtocol *bool `field:"optional" json:"useClientProtocol" yaml:"useClientProtocol"`
}

// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
type DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy string

const (
	// DEFAULT.
	DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy_DEFAULT DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "DEFAULT"
	// DO_NOT_UPGRADE.
	DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy_DO_NOT_UPGRADE DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "DO_NOT_UPGRADE"
	// UPGRADE.
	DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy_UPGRADE DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "UPGRADE"
)

// Settings common to both HTTP and TCP upstream connections.
type DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp struct {
	// TCP connection timeout.
	ConnectTimeout *string `field:"optional" json:"connectTimeout" yaml:"connectTimeout"`
	// The maximum duration of a connection.
	MaxConnectionDuration *string `field:"optional" json:"maxConnectionDuration" yaml:"maxConnectionDuration"`
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections *float64 `field:"optional" json:"maxConnections" yaml:"maxConnections"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive `field:"optional" json:"tcpKeepalive" yaml:"tcpKeepalive"`
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
type DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive struct {
	// The time duration between keep-alive probes.
	Interval *string  `field:"optional" json:"interval" yaml:"interval"`
	Probes   *float64 `field:"optional" json:"probes" yaml:"probes"`
	Time     *string  `field:"optional" json:"time" yaml:"time"`
}

// Settings controlling the load balancer algorithms.
type DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer struct {
	ConsistentHash    *DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash    `field:"optional" json:"consistentHash" yaml:"consistentHash"`
	LocalityLbSetting *DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting `field:"optional" json:"localityLbSetting" yaml:"localityLbSetting"`
	Simple            DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple             `field:"optional" json:"simple" yaml:"simple"`
	// Represents the warmup duration of Service.
	WarmupDurationSecs *string `field:"optional" json:"warmupDurationSecs" yaml:"warmupDurationSecs"`
}

type DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash struct {
	// Hash based on HTTP cookie.
	HttpCookie *DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie `field:"optional" json:"httpCookie" yaml:"httpCookie"`
	// Hash based on a specific HTTP header.
	HttpHeaderName *string `field:"optional" json:"httpHeaderName" yaml:"httpHeaderName"`
	// Hash based on a specific HTTP query parameter.
	HttpQueryParameterName *string  `field:"optional" json:"httpQueryParameterName" yaml:"httpQueryParameterName"`
	MinimumRingSize        *float64 `field:"optional" json:"minimumRingSize" yaml:"minimumRingSize"`
	// Hash based on the source IP address.
	UseSourceIp *bool `field:"optional" json:"useSourceIp" yaml:"useSourceIp"`
}

// Hash based on HTTP cookie.
type DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie struct {
	// Name of the cookie.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Path to set for the cookie.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Lifetime of the cookie.
	Ttl *string `field:"optional" json:"ttl" yaml:"ttl"`
}

type DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Distribute *[]*DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute `field:"optional" json:"distribute" yaml:"distribute"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	Enabled *bool `field:"optional" json:"enabled" yaml:"enabled"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Failover *[]*DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover `field:"optional" json:"failover" yaml:"failover"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	FailoverPriority *[]*string `field:"optional" json:"failoverPriority" yaml:"failoverPriority"`
}

type DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute struct {
	// Originating locality, '/' separated, e.g.
	From *string `field:"optional" json:"from" yaml:"from"`
	// Map of upstream localities to traffic distribution weights.
	To *map[string]*float64 `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover struct {
	// Originating region.
	From *string `field:"optional" json:"from" yaml:"from"`
	To   *string `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple string

const (
	// UNSPECIFIED.
	DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple_UNSPECIFIED DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple = "UNSPECIFIED"
	// LEAST_CONN.
	DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple_LEAST_CONN DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple = "LEAST_CONN"
	// RANDOM.
	DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple_RANDOM DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple = "RANDOM"
	// PASSTHROUGH.
	DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple_PASSTHROUGH DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple = "PASSTHROUGH"
	// ROUND_ROBIN.
	DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple_ROUND_ROBIN DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple = "ROUND_ROBIN"
	// LEAST_REQUEST.
	DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple_LEAST_REQUEST DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple = "LEAST_REQUEST"
)

type DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection struct {
	// Minimum ejection duration.
	BaseEjectionTime *string `field:"optional" json:"baseEjectionTime" yaml:"baseEjectionTime"`
	// Number of 5xx errors before a host is ejected from the connection pool.
	Consecutive5XxErrors *float64 `field:"optional" json:"consecutive5XxErrors" yaml:"consecutive5XxErrors"`
	ConsecutiveErrors    *float64 `field:"optional" json:"consecutiveErrors" yaml:"consecutiveErrors"`
	// Number of gateway errors before a host is ejected from the connection pool.
	ConsecutiveGatewayErrors       *float64 `field:"optional" json:"consecutiveGatewayErrors" yaml:"consecutiveGatewayErrors"`
	ConsecutiveLocalOriginFailures *float64 `field:"optional" json:"consecutiveLocalOriginFailures" yaml:"consecutiveLocalOriginFailures"`
	// Time interval between ejection sweep analysis.
	Interval           *string  `field:"optional" json:"interval" yaml:"interval"`
	MaxEjectionPercent *float64 `field:"optional" json:"maxEjectionPercent" yaml:"maxEjectionPercent"`
	MinHealthPercent   *float64 `field:"optional" json:"minHealthPercent" yaml:"minHealthPercent"`
	// Determines whether to distinguish local origin failures from external errors.
	SplitExternalLocalOriginErrors *bool `field:"optional" json:"splitExternalLocalOriginErrors" yaml:"splitExternalLocalOriginErrors"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings struct {
	ConnectionPool *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool `field:"optional" json:"connectionPool" yaml:"connectionPool"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer     *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer     `field:"optional" json:"loadBalancer" yaml:"loadBalancer"`
	OutlierDetection *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection `field:"optional" json:"outlierDetection" yaml:"outlierDetection"`
	Port             *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort             `field:"optional" json:"port" yaml:"port"`
	// TLS related settings for connections to the upstream service.
	Tls *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls `field:"optional" json:"tls" yaml:"tls"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool struct {
	// HTTP connection pool settings.
	Http *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp `field:"optional" json:"http" yaml:"http"`
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp `field:"optional" json:"tcp" yaml:"tcp"`
}

// HTTP connection pool settings.
type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp struct {
	// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
	H2UpgradePolicy         DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy `field:"optional" json:"h2UpgradePolicy" yaml:"h2UpgradePolicy"`
	Http1MaxPendingRequests *float64                                                                                  `field:"optional" json:"http1MaxPendingRequests" yaml:"http1MaxPendingRequests"`
	// Maximum number of active requests to a destination.
	Http2MaxRequests *float64 `field:"optional" json:"http2MaxRequests" yaml:"http2MaxRequests"`
	// The idle timeout for upstream connection pool connections.
	IdleTimeout *string `field:"optional" json:"idleTimeout" yaml:"idleTimeout"`
	// Maximum number of requests per connection to a backend.
	MaxRequestsPerConnection *float64 `field:"optional" json:"maxRequestsPerConnection" yaml:"maxRequestsPerConnection"`
	MaxRetries               *float64 `field:"optional" json:"maxRetries" yaml:"maxRetries"`
	// If set to true, client protocol will be preserved while initiating connection to backend.
	UseClientProtocol *bool `field:"optional" json:"useClientProtocol" yaml:"useClientProtocol"`
}

// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy string

const (
	// DEFAULT.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_DEFAULT DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "DEFAULT"
	// DO_NOT_UPGRADE.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_DO_NOT_UPGRADE DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "DO_NOT_UPGRADE"
	// UPGRADE.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_UPGRADE DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "UPGRADE"
)

// Settings common to both HTTP and TCP upstream connections.
type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp struct {
	// TCP connection timeout.
	ConnectTimeout *string `field:"optional" json:"connectTimeout" yaml:"connectTimeout"`
	// The maximum duration of a connection.
	MaxConnectionDuration *string `field:"optional" json:"maxConnectionDuration" yaml:"maxConnectionDuration"`
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections *float64 `field:"optional" json:"maxConnections" yaml:"maxConnections"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive `field:"optional" json:"tcpKeepalive" yaml:"tcpKeepalive"`
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive struct {
	// The time duration between keep-alive probes.
	Interval *string  `field:"optional" json:"interval" yaml:"interval"`
	Probes   *float64 `field:"optional" json:"probes" yaml:"probes"`
	Time     *string  `field:"optional" json:"time" yaml:"time"`
}

// Settings controlling the load balancer algorithms.
type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer struct {
	ConsistentHash    *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash    `field:"optional" json:"consistentHash" yaml:"consistentHash"`
	LocalityLbSetting *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting `field:"optional" json:"localityLbSetting" yaml:"localityLbSetting"`
	Simple            DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple             `field:"optional" json:"simple" yaml:"simple"`
	// Represents the warmup duration of Service.
	WarmupDurationSecs *string `field:"optional" json:"warmupDurationSecs" yaml:"warmupDurationSecs"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash struct {
	// Hash based on HTTP cookie.
	HttpCookie *DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie `field:"optional" json:"httpCookie" yaml:"httpCookie"`
	// Hash based on a specific HTTP header.
	HttpHeaderName *string `field:"optional" json:"httpHeaderName" yaml:"httpHeaderName"`
	// Hash based on a specific HTTP query parameter.
	HttpQueryParameterName *string  `field:"optional" json:"httpQueryParameterName" yaml:"httpQueryParameterName"`
	MinimumRingSize        *float64 `field:"optional" json:"minimumRingSize" yaml:"minimumRingSize"`
	// Hash based on the source IP address.
	UseSourceIp *bool `field:"optional" json:"useSourceIp" yaml:"useSourceIp"`
}

// Hash based on HTTP cookie.
type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie struct {
	// Name of the cookie.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Path to set for the cookie.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Lifetime of the cookie.
	Ttl *string `field:"optional" json:"ttl" yaml:"ttl"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Distribute *[]*DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute `field:"optional" json:"distribute" yaml:"distribute"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	Enabled *bool `field:"optional" json:"enabled" yaml:"enabled"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Failover *[]*DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover `field:"optional" json:"failover" yaml:"failover"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	FailoverPriority *[]*string `field:"optional" json:"failoverPriority" yaml:"failoverPriority"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute struct {
	// Originating locality, '/' separated, e.g.
	From *string `field:"optional" json:"from" yaml:"from"`
	// Map of upstream localities to traffic distribution weights.
	To *map[string]*float64 `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover struct {
	// Originating region.
	From *string `field:"optional" json:"from" yaml:"from"`
	To   *string `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple string

const (
	// UNSPECIFIED.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_UNSPECIFIED DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "UNSPECIFIED"
	// LEAST_CONN.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_LEAST_CONN DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "LEAST_CONN"
	// RANDOM.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_RANDOM DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "RANDOM"
	// PASSTHROUGH.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_PASSTHROUGH DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "PASSTHROUGH"
	// ROUND_ROBIN.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_ROUND_ROBIN DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "ROUND_ROBIN"
	// LEAST_REQUEST.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_LEAST_REQUEST DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "LEAST_REQUEST"
)

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection struct {
	// Minimum ejection duration.
	BaseEjectionTime *string `field:"optional" json:"baseEjectionTime" yaml:"baseEjectionTime"`
	// Number of 5xx errors before a host is ejected from the connection pool.
	Consecutive5XxErrors *float64 `field:"optional" json:"consecutive5XxErrors" yaml:"consecutive5XxErrors"`
	ConsecutiveErrors    *float64 `field:"optional" json:"consecutiveErrors" yaml:"consecutiveErrors"`
	// Number of gateway errors before a host is ejected from the connection pool.
	ConsecutiveGatewayErrors       *float64 `field:"optional" json:"consecutiveGatewayErrors" yaml:"consecutiveGatewayErrors"`
	ConsecutiveLocalOriginFailures *float64 `field:"optional" json:"consecutiveLocalOriginFailures" yaml:"consecutiveLocalOriginFailures"`
	// Time interval between ejection sweep analysis.
	Interval           *string  `field:"optional" json:"interval" yaml:"interval"`
	MaxEjectionPercent *float64 `field:"optional" json:"maxEjectionPercent" yaml:"maxEjectionPercent"`
	MinHealthPercent   *float64 `field:"optional" json:"minHealthPercent" yaml:"minHealthPercent"`
	// Determines whether to distinguish local origin failures from external errors.
	SplitExternalLocalOriginErrors *bool `field:"optional" json:"splitExternalLocalOriginErrors" yaml:"splitExternalLocalOriginErrors"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

// TLS related settings for connections to the upstream service.
type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls struct {
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// REQUIRED if mode is `MUTUAL`.
	ClientCertificate  *string                                                         `field:"optional" json:"clientCertificate" yaml:"clientCertificate"`
	CredentialName     *string                                                         `field:"optional" json:"credentialName" yaml:"credentialName"`
	InsecureSkipVerify *bool                                                           `field:"optional" json:"insecureSkipVerify" yaml:"insecureSkipVerify"`
	Mode               DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// SNI string to present to the server during TLS handshake.
	Sni             *string    `field:"optional" json:"sni" yaml:"sni"`
	SubjectAltNames *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
}

type DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode string

const (
	// DISABLE.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode_DISABLE DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode = "DISABLE"
	// SIMPLE.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode_SIMPLE DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode = "SIMPLE"
	// MUTUAL.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode_MUTUAL DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode = "MUTUAL"
	// ISTIO_MUTUAL.
	DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode_ISTIO_MUTUAL DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode = "ISTIO_MUTUAL"
)

// TLS related settings for connections to the upstream service.
type DestinationRuleSpecSubsetsTrafficPolicyTls struct {
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// REQUIRED if mode is `MUTUAL`.
	ClientCertificate  *string                                        `field:"optional" json:"clientCertificate" yaml:"clientCertificate"`
	CredentialName     *string                                        `field:"optional" json:"credentialName" yaml:"credentialName"`
	InsecureSkipVerify *bool                                          `field:"optional" json:"insecureSkipVerify" yaml:"insecureSkipVerify"`
	Mode               DestinationRuleSpecSubsetsTrafficPolicyTlsMode `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// SNI string to present to the server during TLS handshake.
	Sni             *string    `field:"optional" json:"sni" yaml:"sni"`
	SubjectAltNames *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
}

type DestinationRuleSpecSubsetsTrafficPolicyTlsMode string

const (
	// DISABLE.
	DestinationRuleSpecSubsetsTrafficPolicyTlsMode_DISABLE DestinationRuleSpecSubsetsTrafficPolicyTlsMode = "DISABLE"
	// SIMPLE.
	DestinationRuleSpecSubsetsTrafficPolicyTlsMode_SIMPLE DestinationRuleSpecSubsetsTrafficPolicyTlsMode = "SIMPLE"
	// MUTUAL.
	DestinationRuleSpecSubsetsTrafficPolicyTlsMode_MUTUAL DestinationRuleSpecSubsetsTrafficPolicyTlsMode = "MUTUAL"
	// ISTIO_MUTUAL.
	DestinationRuleSpecSubsetsTrafficPolicyTlsMode_ISTIO_MUTUAL DestinationRuleSpecSubsetsTrafficPolicyTlsMode = "ISTIO_MUTUAL"
)

type DestinationRuleSpecSubsetsTrafficPolicyTunnel struct {
	// Specifies which protocol to use for tunneling the downstream connection.
	Protocol *string `field:"optional" json:"protocol" yaml:"protocol"`
	// Specifies a host to which the downstream connection is tunneled.
	TargetHost *string `field:"optional" json:"targetHost" yaml:"targetHost"`
	// Specifies a port to which the downstream connection is tunneled.
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

type DestinationRuleSpecTrafficPolicy struct {
	ConnectionPool *DestinationRuleSpecTrafficPolicyConnectionPool `field:"optional" json:"connectionPool" yaml:"connectionPool"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer     *DestinationRuleSpecTrafficPolicyLoadBalancer     `field:"optional" json:"loadBalancer" yaml:"loadBalancer"`
	OutlierDetection *DestinationRuleSpecTrafficPolicyOutlierDetection `field:"optional" json:"outlierDetection" yaml:"outlierDetection"`
	// Traffic policies specific to individual ports.
	PortLevelSettings *[]*DestinationRuleSpecTrafficPolicyPortLevelSettings `field:"optional" json:"portLevelSettings" yaml:"portLevelSettings"`
	// TLS related settings for connections to the upstream service.
	Tls    *DestinationRuleSpecTrafficPolicyTls    `field:"optional" json:"tls" yaml:"tls"`
	Tunnel *DestinationRuleSpecTrafficPolicyTunnel `field:"optional" json:"tunnel" yaml:"tunnel"`
}

type DestinationRuleSpecTrafficPolicyConnectionPool struct {
	// HTTP connection pool settings.
	Http *DestinationRuleSpecTrafficPolicyConnectionPoolHttp `field:"optional" json:"http" yaml:"http"`
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *DestinationRuleSpecTrafficPolicyConnectionPoolTcp `field:"optional" json:"tcp" yaml:"tcp"`
}

// HTTP connection pool settings.
type DestinationRuleSpecTrafficPolicyConnectionPoolHttp struct {
	// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
	H2UpgradePolicy         DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy `field:"optional" json:"h2UpgradePolicy" yaml:"h2UpgradePolicy"`
	Http1MaxPendingRequests *float64                                                          `field:"optional" json:"http1MaxPendingRequests" yaml:"http1MaxPendingRequests"`
	// Maximum number of active requests to a destination.
	Http2MaxRequests *float64 `field:"optional" json:"http2MaxRequests" yaml:"http2MaxRequests"`
	// The idle timeout for upstream connection pool connections.
	IdleTimeout *string `field:"optional" json:"idleTimeout" yaml:"idleTimeout"`
	// Maximum number of requests per connection to a backend.
	MaxRequestsPerConnection *float64 `field:"optional" json:"maxRequestsPerConnection" yaml:"maxRequestsPerConnection"`
	MaxRetries               *float64 `field:"optional" json:"maxRetries" yaml:"maxRetries"`
	// If set to true, client protocol will be preserved while initiating connection to backend.
	UseClientProtocol *bool `field:"optional" json:"useClientProtocol" yaml:"useClientProtocol"`
}

// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
type DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy string

const (
	// DEFAULT.
	DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy_DEFAULT DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "DEFAULT"
	// DO_NOT_UPGRADE.
	DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy_DO_NOT_UPGRADE DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "DO_NOT_UPGRADE"
	// UPGRADE.
	DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy_UPGRADE DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "UPGRADE"
)

// Settings common to both HTTP and TCP upstream connections.
type DestinationRuleSpecTrafficPolicyConnectionPoolTcp struct {
	// TCP connection timeout.
	ConnectTimeout *string `field:"optional" json:"connectTimeout" yaml:"connectTimeout"`
	// The maximum duration of a connection.
	MaxConnectionDuration *string `field:"optional" json:"maxConnectionDuration" yaml:"maxConnectionDuration"`
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections *float64 `field:"optional" json:"maxConnections" yaml:"maxConnections"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive `field:"optional" json:"tcpKeepalive" yaml:"tcpKeepalive"`
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
type DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive struct {
	// The time duration between keep-alive probes.
	Interval *string  `field:"optional" json:"interval" yaml:"interval"`
	Probes   *float64 `field:"optional" json:"probes" yaml:"probes"`
	Time     *string  `field:"optional" json:"time" yaml:"time"`
}

// Settings controlling the load balancer algorithms.
type DestinationRuleSpecTrafficPolicyLoadBalancer struct {
	ConsistentHash    *DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash    `field:"optional" json:"consistentHash" yaml:"consistentHash"`
	LocalityLbSetting *DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting `field:"optional" json:"localityLbSetting" yaml:"localityLbSetting"`
	Simple            DestinationRuleSpecTrafficPolicyLoadBalancerSimple             `field:"optional" json:"simple" yaml:"simple"`
	// Represents the warmup duration of Service.
	WarmupDurationSecs *string `field:"optional" json:"warmupDurationSecs" yaml:"warmupDurationSecs"`
}

type DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash struct {
	// Hash based on HTTP cookie.
	HttpCookie *DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie `field:"optional" json:"httpCookie" yaml:"httpCookie"`
	// Hash based on a specific HTTP header.
	HttpHeaderName *string `field:"optional" json:"httpHeaderName" yaml:"httpHeaderName"`
	// Hash based on a specific HTTP query parameter.
	HttpQueryParameterName *string  `field:"optional" json:"httpQueryParameterName" yaml:"httpQueryParameterName"`
	MinimumRingSize        *float64 `field:"optional" json:"minimumRingSize" yaml:"minimumRingSize"`
	// Hash based on the source IP address.
	UseSourceIp *bool `field:"optional" json:"useSourceIp" yaml:"useSourceIp"`
}

// Hash based on HTTP cookie.
type DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie struct {
	// Name of the cookie.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Path to set for the cookie.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Lifetime of the cookie.
	Ttl *string `field:"optional" json:"ttl" yaml:"ttl"`
}

type DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Distribute *[]*DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute `field:"optional" json:"distribute" yaml:"distribute"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	Enabled *bool `field:"optional" json:"enabled" yaml:"enabled"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Failover *[]*DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover `field:"optional" json:"failover" yaml:"failover"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	FailoverPriority *[]*string `field:"optional" json:"failoverPriority" yaml:"failoverPriority"`
}

type DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute struct {
	// Originating locality, '/' separated, e.g.
	From *string `field:"optional" json:"from" yaml:"from"`
	// Map of upstream localities to traffic distribution weights.
	To *map[string]*float64 `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover struct {
	// Originating region.
	From *string `field:"optional" json:"from" yaml:"from"`
	To   *string `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleSpecTrafficPolicyLoadBalancerSimple string

const (
	// UNSPECIFIED.
	DestinationRuleSpecTrafficPolicyLoadBalancerSimple_UNSPECIFIED DestinationRuleSpecTrafficPolicyLoadBalancerSimple = "UNSPECIFIED"
	// LEAST_CONN.
	DestinationRuleSpecTrafficPolicyLoadBalancerSimple_LEAST_CONN DestinationRuleSpecTrafficPolicyLoadBalancerSimple = "LEAST_CONN"
	// RANDOM.
	DestinationRuleSpecTrafficPolicyLoadBalancerSimple_RANDOM DestinationRuleSpecTrafficPolicyLoadBalancerSimple = "RANDOM"
	// PASSTHROUGH.
	DestinationRuleSpecTrafficPolicyLoadBalancerSimple_PASSTHROUGH DestinationRuleSpecTrafficPolicyLoadBalancerSimple = "PASSTHROUGH"
	// ROUND_ROBIN.
	DestinationRuleSpecTrafficPolicyLoadBalancerSimple_ROUND_ROBIN DestinationRuleSpecTrafficPolicyLoadBalancerSimple = "ROUND_ROBIN"
	// LEAST_REQUEST.
	DestinationRuleSpecTrafficPolicyLoadBalancerSimple_LEAST_REQUEST DestinationRuleSpecTrafficPolicyLoadBalancerSimple = "LEAST_REQUEST"
)

type DestinationRuleSpecTrafficPolicyOutlierDetection struct {
	// Minimum ejection duration.
	BaseEjectionTime *string `field:"optional" json:"baseEjectionTime" yaml:"baseEjectionTime"`
	// Number of 5xx errors before a host is ejected from the connection pool.
	Consecutive5XxErrors *float64 `field:"optional" json:"consecutive5XxErrors" yaml:"consecutive5XxErrors"`
	ConsecutiveErrors    *float64 `field:"optional" json:"consecutiveErrors" yaml:"consecutiveErrors"`
	// Number of gateway errors before a host is ejected from the connection pool.
	ConsecutiveGatewayErrors       *float64 `field:"optional" json:"consecutiveGatewayErrors" yaml:"consecutiveGatewayErrors"`
	ConsecutiveLocalOriginFailures *float64 `field:"optional" json:"consecutiveLocalOriginFailures" yaml:"consecutiveLocalOriginFailures"`
	// Time interval between ejection sweep analysis.
	Interval           *string  `field:"optional" json:"interval" yaml:"interval"`
	MaxEjectionPercent *float64 `field:"optional" json:"maxEjectionPercent" yaml:"maxEjectionPercent"`
	MinHealthPercent   *float64 `field:"optional" json:"minHealthPercent" yaml:"minHealthPercent"`
	// Determines whether to distinguish local origin failures from external errors.
	SplitExternalLocalOriginErrors *bool `field:"optional" json:"splitExternalLocalOriginErrors" yaml:"splitExternalLocalOriginErrors"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettings struct {
	ConnectionPool *DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool `field:"optional" json:"connectionPool" yaml:"connectionPool"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer     *DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer     `field:"optional" json:"loadBalancer" yaml:"loadBalancer"`
	OutlierDetection *DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection `field:"optional" json:"outlierDetection" yaml:"outlierDetection"`
	Port             *DestinationRuleSpecTrafficPolicyPortLevelSettingsPort             `field:"optional" json:"port" yaml:"port"`
	// TLS related settings for connections to the upstream service.
	Tls *DestinationRuleSpecTrafficPolicyPortLevelSettingsTls `field:"optional" json:"tls" yaml:"tls"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool struct {
	// HTTP connection pool settings.
	Http *DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp `field:"optional" json:"http" yaml:"http"`
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp `field:"optional" json:"tcp" yaml:"tcp"`
}

// HTTP connection pool settings.
type DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp struct {
	// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
	H2UpgradePolicy         DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy `field:"optional" json:"h2UpgradePolicy" yaml:"h2UpgradePolicy"`
	Http1MaxPendingRequests *float64                                                                           `field:"optional" json:"http1MaxPendingRequests" yaml:"http1MaxPendingRequests"`
	// Maximum number of active requests to a destination.
	Http2MaxRequests *float64 `field:"optional" json:"http2MaxRequests" yaml:"http2MaxRequests"`
	// The idle timeout for upstream connection pool connections.
	IdleTimeout *string `field:"optional" json:"idleTimeout" yaml:"idleTimeout"`
	// Maximum number of requests per connection to a backend.
	MaxRequestsPerConnection *float64 `field:"optional" json:"maxRequestsPerConnection" yaml:"maxRequestsPerConnection"`
	MaxRetries               *float64 `field:"optional" json:"maxRetries" yaml:"maxRetries"`
	// If set to true, client protocol will be preserved while initiating connection to backend.
	UseClientProtocol *bool `field:"optional" json:"useClientProtocol" yaml:"useClientProtocol"`
}

// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
type DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy string

const (
	// DEFAULT.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_DEFAULT DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "DEFAULT"
	// DO_NOT_UPGRADE.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_DO_NOT_UPGRADE DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "DO_NOT_UPGRADE"
	// UPGRADE.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_UPGRADE DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "UPGRADE"
)

// Settings common to both HTTP and TCP upstream connections.
type DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp struct {
	// TCP connection timeout.
	ConnectTimeout *string `field:"optional" json:"connectTimeout" yaml:"connectTimeout"`
	// The maximum duration of a connection.
	MaxConnectionDuration *string `field:"optional" json:"maxConnectionDuration" yaml:"maxConnectionDuration"`
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections *float64 `field:"optional" json:"maxConnections" yaml:"maxConnections"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive `field:"optional" json:"tcpKeepalive" yaml:"tcpKeepalive"`
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
type DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive struct {
	// The time duration between keep-alive probes.
	Interval *string  `field:"optional" json:"interval" yaml:"interval"`
	Probes   *float64 `field:"optional" json:"probes" yaml:"probes"`
	Time     *string  `field:"optional" json:"time" yaml:"time"`
}

// Settings controlling the load balancer algorithms.
type DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer struct {
	ConsistentHash    *DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash    `field:"optional" json:"consistentHash" yaml:"consistentHash"`
	LocalityLbSetting *DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting `field:"optional" json:"localityLbSetting" yaml:"localityLbSetting"`
	Simple            DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple             `field:"optional" json:"simple" yaml:"simple"`
	// Represents the warmup duration of Service.
	WarmupDurationSecs *string `field:"optional" json:"warmupDurationSecs" yaml:"warmupDurationSecs"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash struct {
	// Hash based on HTTP cookie.
	HttpCookie *DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie `field:"optional" json:"httpCookie" yaml:"httpCookie"`
	// Hash based on a specific HTTP header.
	HttpHeaderName *string `field:"optional" json:"httpHeaderName" yaml:"httpHeaderName"`
	// Hash based on a specific HTTP query parameter.
	HttpQueryParameterName *string  `field:"optional" json:"httpQueryParameterName" yaml:"httpQueryParameterName"`
	MinimumRingSize        *float64 `field:"optional" json:"minimumRingSize" yaml:"minimumRingSize"`
	// Hash based on the source IP address.
	UseSourceIp *bool `field:"optional" json:"useSourceIp" yaml:"useSourceIp"`
}

// Hash based on HTTP cookie.
type DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie struct {
	// Name of the cookie.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Path to set for the cookie.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Lifetime of the cookie.
	Ttl *string `field:"optional" json:"ttl" yaml:"ttl"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Distribute *[]*DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute `field:"optional" json:"distribute" yaml:"distribute"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	Enabled *bool `field:"optional" json:"enabled" yaml:"enabled"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Failover *[]*DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover `field:"optional" json:"failover" yaml:"failover"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	FailoverPriority *[]*string `field:"optional" json:"failoverPriority" yaml:"failoverPriority"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute struct {
	// Originating locality, '/' separated, e.g.
	From *string `field:"optional" json:"from" yaml:"from"`
	// Map of upstream localities to traffic distribution weights.
	To *map[string]*float64 `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover struct {
	// Originating region.
	From *string `field:"optional" json:"from" yaml:"from"`
	To   *string `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple string

const (
	// UNSPECIFIED.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_UNSPECIFIED DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "UNSPECIFIED"
	// LEAST_CONN.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_LEAST_CONN DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "LEAST_CONN"
	// RANDOM.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_RANDOM DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "RANDOM"
	// PASSTHROUGH.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_PASSTHROUGH DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "PASSTHROUGH"
	// ROUND_ROBIN.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_ROUND_ROBIN DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "ROUND_ROBIN"
	// LEAST_REQUEST.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_LEAST_REQUEST DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "LEAST_REQUEST"
)

type DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection struct {
	// Minimum ejection duration.
	BaseEjectionTime *string `field:"optional" json:"baseEjectionTime" yaml:"baseEjectionTime"`
	// Number of 5xx errors before a host is ejected from the connection pool.
	Consecutive5XxErrors *float64 `field:"optional" json:"consecutive5XxErrors" yaml:"consecutive5XxErrors"`
	ConsecutiveErrors    *float64 `field:"optional" json:"consecutiveErrors" yaml:"consecutiveErrors"`
	// Number of gateway errors before a host is ejected from the connection pool.
	ConsecutiveGatewayErrors       *float64 `field:"optional" json:"consecutiveGatewayErrors" yaml:"consecutiveGatewayErrors"`
	ConsecutiveLocalOriginFailures *float64 `field:"optional" json:"consecutiveLocalOriginFailures" yaml:"consecutiveLocalOriginFailures"`
	// Time interval between ejection sweep analysis.
	Interval           *string  `field:"optional" json:"interval" yaml:"interval"`
	MaxEjectionPercent *float64 `field:"optional" json:"maxEjectionPercent" yaml:"maxEjectionPercent"`
	MinHealthPercent   *float64 `field:"optional" json:"minHealthPercent" yaml:"minHealthPercent"`
	// Determines whether to distinguish local origin failures from external errors.
	SplitExternalLocalOriginErrors *bool `field:"optional" json:"splitExternalLocalOriginErrors" yaml:"splitExternalLocalOriginErrors"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettingsPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

// TLS related settings for connections to the upstream service.
type DestinationRuleSpecTrafficPolicyPortLevelSettingsTls struct {
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// REQUIRED if mode is `MUTUAL`.
	ClientCertificate  *string                                                  `field:"optional" json:"clientCertificate" yaml:"clientCertificate"`
	CredentialName     *string                                                  `field:"optional" json:"credentialName" yaml:"credentialName"`
	InsecureSkipVerify *bool                                                    `field:"optional" json:"insecureSkipVerify" yaml:"insecureSkipVerify"`
	Mode               DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// SNI string to present to the server during TLS handshake.
	Sni             *string    `field:"optional" json:"sni" yaml:"sni"`
	SubjectAltNames *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
}

type DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode string

const (
	// DISABLE.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode_DISABLE DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode = "DISABLE"
	// SIMPLE.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode_SIMPLE DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode = "SIMPLE"
	// MUTUAL.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode_MUTUAL DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode = "MUTUAL"
	// ISTIO_MUTUAL.
	DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode_ISTIO_MUTUAL DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode = "ISTIO_MUTUAL"
)

// TLS related settings for connections to the upstream service.
type DestinationRuleSpecTrafficPolicyTls struct {
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// REQUIRED if mode is `MUTUAL`.
	ClientCertificate  *string                                 `field:"optional" json:"clientCertificate" yaml:"clientCertificate"`
	CredentialName     *string                                 `field:"optional" json:"credentialName" yaml:"credentialName"`
	InsecureSkipVerify *bool                                   `field:"optional" json:"insecureSkipVerify" yaml:"insecureSkipVerify"`
	Mode               DestinationRuleSpecTrafficPolicyTlsMode `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// SNI string to present to the server during TLS handshake.
	Sni             *string    `field:"optional" json:"sni" yaml:"sni"`
	SubjectAltNames *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
}

type DestinationRuleSpecTrafficPolicyTlsMode string

const (
	// DISABLE.
	DestinationRuleSpecTrafficPolicyTlsMode_DISABLE DestinationRuleSpecTrafficPolicyTlsMode = "DISABLE"
	// SIMPLE.
	DestinationRuleSpecTrafficPolicyTlsMode_SIMPLE DestinationRuleSpecTrafficPolicyTlsMode = "SIMPLE"
	// MUTUAL.
	DestinationRuleSpecTrafficPolicyTlsMode_MUTUAL DestinationRuleSpecTrafficPolicyTlsMode = "MUTUAL"
	// ISTIO_MUTUAL.
	DestinationRuleSpecTrafficPolicyTlsMode_ISTIO_MUTUAL DestinationRuleSpecTrafficPolicyTlsMode = "ISTIO_MUTUAL"
)

type DestinationRuleSpecTrafficPolicyTunnel struct {
	// Specifies which protocol to use for tunneling the downstream connection.
	Protocol *string `field:"optional" json:"protocol" yaml:"protocol"`
	// Specifies a host to which the downstream connection is tunneled.
	TargetHost *string `field:"optional" json:"targetHost" yaml:"targetHost"`
	// Specifies a port to which the downstream connection is tunneled.
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

type DestinationRuleSpecWorkloadSelector struct {
	MatchLabels *map[string]*string `field:"optional" json:"matchLabels" yaml:"matchLabels"`
}

type DestinationRuleV1Beta1 interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for DestinationRuleV1Beta1
type jsiiProxy_DestinationRuleV1Beta1 struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_DestinationRuleV1Beta1) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRuleV1Beta1) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRuleV1Beta1) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRuleV1Beta1) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRuleV1Beta1) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRuleV1Beta1) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_DestinationRuleV1Beta1) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "DestinationRuleV1Beta1" API object.
func NewDestinationRuleV1Beta1(scope constructs.Construct, id *string, props *DestinationRuleV1Beta1Props) DestinationRuleV1Beta1 {
	_init_.Initialize()

	j := jsiiProxy_DestinationRuleV1Beta1{}

	_jsii_.Create(
		"networkingistioio.DestinationRuleV1Beta1",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "DestinationRuleV1Beta1" API object.
func NewDestinationRuleV1Beta1_Override(d DestinationRuleV1Beta1, scope constructs.Construct, id *string, props *DestinationRuleV1Beta1Props) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.DestinationRuleV1Beta1",
		[]interface{}{scope, id, props},
		d,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func DestinationRuleV1Beta1_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.DestinationRuleV1Beta1",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "DestinationRuleV1Beta1".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func DestinationRuleV1Beta1_Manifest(props *DestinationRuleV1Beta1Props) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.DestinationRuleV1Beta1",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func DestinationRuleV1Beta1_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.DestinationRuleV1Beta1",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func DestinationRuleV1Beta1_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.DestinationRuleV1Beta1",
		"GVK",
		&returns,
	)
	return returns
}

func (d *jsiiProxy_DestinationRuleV1Beta1) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		d,
		"addDependency",
		args,
	)
}

func (d *jsiiProxy_DestinationRuleV1Beta1) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		d,
		"addJsonPatch",
		args,
	)
}

func (d *jsiiProxy_DestinationRuleV1Beta1) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		d,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (d *jsiiProxy_DestinationRuleV1Beta1) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		d,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type DestinationRuleV1Beta1Props struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting load balancing, outlier detection, etc.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
	Spec *DestinationRuleV1Beta1Spec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting load balancing, outlier detection, etc.
//
// See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
type DestinationRuleV1Beta1Spec struct {
	// A list of namespaces to which this destination rule is exported.
	ExportTo *[]*string `field:"optional" json:"exportTo" yaml:"exportTo"`
	// The name of a service from the service registry.
	Host             *string                                     `field:"optional" json:"host" yaml:"host"`
	Subsets          *[]*DestinationRuleV1Beta1SpecSubsets       `field:"optional" json:"subsets" yaml:"subsets"`
	TrafficPolicy    *DestinationRuleV1Beta1SpecTrafficPolicy    `field:"optional" json:"trafficPolicy" yaml:"trafficPolicy"`
	WorkloadSelector *DestinationRuleV1Beta1SpecWorkloadSelector `field:"optional" json:"workloadSelector" yaml:"workloadSelector"`
}

type DestinationRuleV1Beta1SpecSubsets struct {
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
	// Name of the subset.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Traffic policies that apply to this subset.
	TrafficPolicy *DestinationRuleV1Beta1SpecSubsetsTrafficPolicy `field:"optional" json:"trafficPolicy" yaml:"trafficPolicy"`
}

// Traffic policies that apply to this subset.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicy struct {
	ConnectionPool *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool `field:"optional" json:"connectionPool" yaml:"connectionPool"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer     *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer     `field:"optional" json:"loadBalancer" yaml:"loadBalancer"`
	OutlierDetection *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection `field:"optional" json:"outlierDetection" yaml:"outlierDetection"`
	// Traffic policies specific to individual ports.
	PortLevelSettings *[]*DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings `field:"optional" json:"portLevelSettings" yaml:"portLevelSettings"`
	// TLS related settings for connections to the upstream service.
	Tls    *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls    `field:"optional" json:"tls" yaml:"tls"`
	Tunnel *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel `field:"optional" json:"tunnel" yaml:"tunnel"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool struct {
	// HTTP connection pool settings.
	Http *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp `field:"optional" json:"http" yaml:"http"`
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp `field:"optional" json:"tcp" yaml:"tcp"`
}

// HTTP connection pool settings.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp struct {
	// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
	H2UpgradePolicy         DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy `field:"optional" json:"h2UpgradePolicy" yaml:"h2UpgradePolicy"`
	Http1MaxPendingRequests *float64                                                                        `field:"optional" json:"http1MaxPendingRequests" yaml:"http1MaxPendingRequests"`
	// Maximum number of active requests to a destination.
	Http2MaxRequests *float64 `field:"optional" json:"http2MaxRequests" yaml:"http2MaxRequests"`
	// The idle timeout for upstream connection pool connections.
	IdleTimeout *string `field:"optional" json:"idleTimeout" yaml:"idleTimeout"`
	// Maximum number of requests per connection to a backend.
	MaxRequestsPerConnection *float64 `field:"optional" json:"maxRequestsPerConnection" yaml:"maxRequestsPerConnection"`
	MaxRetries               *float64 `field:"optional" json:"maxRetries" yaml:"maxRetries"`
	// If set to true, client protocol will be preserved while initiating connection to backend.
	UseClientProtocol *bool `field:"optional" json:"useClientProtocol" yaml:"useClientProtocol"`
}

// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy string

const (
	// DEFAULT.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy_DEFAULT DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "DEFAULT"
	// DO_NOT_UPGRADE.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy_DO_NOT_UPGRADE DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "DO_NOT_UPGRADE"
	// UPGRADE.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy_UPGRADE DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "UPGRADE"
)

// Settings common to both HTTP and TCP upstream connections.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp struct {
	// TCP connection timeout.
	ConnectTimeout *string `field:"optional" json:"connectTimeout" yaml:"connectTimeout"`
	// The maximum duration of a connection.
	MaxConnectionDuration *string `field:"optional" json:"maxConnectionDuration" yaml:"maxConnectionDuration"`
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections *float64 `field:"optional" json:"maxConnections" yaml:"maxConnections"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive `field:"optional" json:"tcpKeepalive" yaml:"tcpKeepalive"`
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive struct {
	// The time duration between keep-alive probes.
	Interval *string  `field:"optional" json:"interval" yaml:"interval"`
	Probes   *float64 `field:"optional" json:"probes" yaml:"probes"`
	Time     *string  `field:"optional" json:"time" yaml:"time"`
}

// Settings controlling the load balancer algorithms.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer struct {
	ConsistentHash    *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash    `field:"optional" json:"consistentHash" yaml:"consistentHash"`
	LocalityLbSetting *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting `field:"optional" json:"localityLbSetting" yaml:"localityLbSetting"`
	Simple            DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple             `field:"optional" json:"simple" yaml:"simple"`
	// Represents the warmup duration of Service.
	WarmupDurationSecs *string `field:"optional" json:"warmupDurationSecs" yaml:"warmupDurationSecs"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash struct {
	// Hash based on HTTP cookie.
	HttpCookie *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie `field:"optional" json:"httpCookie" yaml:"httpCookie"`
	// Hash based on a specific HTTP header.
	HttpHeaderName *string `field:"optional" json:"httpHeaderName" yaml:"httpHeaderName"`
	// Hash based on a specific HTTP query parameter.
	HttpQueryParameterName *string  `field:"optional" json:"httpQueryParameterName" yaml:"httpQueryParameterName"`
	MinimumRingSize        *float64 `field:"optional" json:"minimumRingSize" yaml:"minimumRingSize"`
	// Hash based on the source IP address.
	UseSourceIp *bool `field:"optional" json:"useSourceIp" yaml:"useSourceIp"`
}

// Hash based on HTTP cookie.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie struct {
	// Name of the cookie.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Path to set for the cookie.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Lifetime of the cookie.
	Ttl *string `field:"optional" json:"ttl" yaml:"ttl"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Distribute *[]*DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute `field:"optional" json:"distribute" yaml:"distribute"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	Enabled *bool `field:"optional" json:"enabled" yaml:"enabled"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Failover *[]*DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover `field:"optional" json:"failover" yaml:"failover"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	FailoverPriority *[]*string `field:"optional" json:"failoverPriority" yaml:"failoverPriority"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute struct {
	// Originating locality, '/' separated, e.g.
	From *string `field:"optional" json:"from" yaml:"from"`
	// Map of upstream localities to traffic distribution weights.
	To *map[string]*float64 `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover struct {
	// Originating region.
	From *string `field:"optional" json:"from" yaml:"from"`
	To   *string `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple string

const (
	// UNSPECIFIED.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple_UNSPECIFIED DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple = "UNSPECIFIED"
	// LEAST_CONN.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple_LEAST_CONN DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple = "LEAST_CONN"
	// RANDOM.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple_RANDOM DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple = "RANDOM"
	// PASSTHROUGH.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple_PASSTHROUGH DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple = "PASSTHROUGH"
	// ROUND_ROBIN.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple_ROUND_ROBIN DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple = "ROUND_ROBIN"
	// LEAST_REQUEST.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple_LEAST_REQUEST DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple = "LEAST_REQUEST"
)

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection struct {
	// Minimum ejection duration.
	BaseEjectionTime *string `field:"optional" json:"baseEjectionTime" yaml:"baseEjectionTime"`
	// Number of 5xx errors before a host is ejected from the connection pool.
	Consecutive5XxErrors *float64 `field:"optional" json:"consecutive5XxErrors" yaml:"consecutive5XxErrors"`
	ConsecutiveErrors    *float64 `field:"optional" json:"consecutiveErrors" yaml:"consecutiveErrors"`
	// Number of gateway errors before a host is ejected from the connection pool.
	ConsecutiveGatewayErrors       *float64 `field:"optional" json:"consecutiveGatewayErrors" yaml:"consecutiveGatewayErrors"`
	ConsecutiveLocalOriginFailures *float64 `field:"optional" json:"consecutiveLocalOriginFailures" yaml:"consecutiveLocalOriginFailures"`
	// Time interval between ejection sweep analysis.
	Interval           *string  `field:"optional" json:"interval" yaml:"interval"`
	MaxEjectionPercent *float64 `field:"optional" json:"maxEjectionPercent" yaml:"maxEjectionPercent"`
	MinHealthPercent   *float64 `field:"optional" json:"minHealthPercent" yaml:"minHealthPercent"`
	// Determines whether to distinguish local origin failures from external errors.
	SplitExternalLocalOriginErrors *bool `field:"optional" json:"splitExternalLocalOriginErrors" yaml:"splitExternalLocalOriginErrors"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings struct {
	ConnectionPool *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool `field:"optional" json:"connectionPool" yaml:"connectionPool"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer     *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer     `field:"optional" json:"loadBalancer" yaml:"loadBalancer"`
	OutlierDetection *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection `field:"optional" json:"outlierDetection" yaml:"outlierDetection"`
	Port             *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort             `field:"optional" json:"port" yaml:"port"`
	// TLS related settings for connections to the upstream service.
	Tls *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls `field:"optional" json:"tls" yaml:"tls"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool struct {
	// HTTP connection pool settings.
	Http *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp `field:"optional" json:"http" yaml:"http"`
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp `field:"optional" json:"tcp" yaml:"tcp"`
}

// HTTP connection pool settings.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp struct {
	// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
	H2UpgradePolicy         DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy `field:"optional" json:"h2UpgradePolicy" yaml:"h2UpgradePolicy"`
	Http1MaxPendingRequests *float64                                                                                         `field:"optional" json:"http1MaxPendingRequests" yaml:"http1MaxPendingRequests"`
	// Maximum number of active requests to a destination.
	Http2MaxRequests *float64 `field:"optional" json:"http2MaxRequests" yaml:"http2MaxRequests"`
	// The idle timeout for upstream connection pool connections.
	IdleTimeout *string `field:"optional" json:"idleTimeout" yaml:"idleTimeout"`
	// Maximum number of requests per connection to a backend.
	MaxRequestsPerConnection *float64 `field:"optional" json:"maxRequestsPerConnection" yaml:"maxRequestsPerConnection"`
	MaxRetries               *float64 `field:"optional" json:"maxRetries" yaml:"maxRetries"`
	// If set to true, client protocol will be preserved while initiating connection to backend.
	UseClientProtocol *bool `field:"optional" json:"useClientProtocol" yaml:"useClientProtocol"`
}

// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy string

const (
	// DEFAULT.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_DEFAULT DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "DEFAULT"
	// DO_NOT_UPGRADE.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_DO_NOT_UPGRADE DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "DO_NOT_UPGRADE"
	// UPGRADE.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_UPGRADE DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "UPGRADE"
)

// Settings common to both HTTP and TCP upstream connections.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp struct {
	// TCP connection timeout.
	ConnectTimeout *string `field:"optional" json:"connectTimeout" yaml:"connectTimeout"`
	// The maximum duration of a connection.
	MaxConnectionDuration *string `field:"optional" json:"maxConnectionDuration" yaml:"maxConnectionDuration"`
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections *float64 `field:"optional" json:"maxConnections" yaml:"maxConnections"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive `field:"optional" json:"tcpKeepalive" yaml:"tcpKeepalive"`
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive struct {
	// The time duration between keep-alive probes.
	Interval *string  `field:"optional" json:"interval" yaml:"interval"`
	Probes   *float64 `field:"optional" json:"probes" yaml:"probes"`
	Time     *string  `field:"optional" json:"time" yaml:"time"`
}

// Settings controlling the load balancer algorithms.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer struct {
	ConsistentHash    *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash    `field:"optional" json:"consistentHash" yaml:"consistentHash"`
	LocalityLbSetting *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting `field:"optional" json:"localityLbSetting" yaml:"localityLbSetting"`
	Simple            DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple             `field:"optional" json:"simple" yaml:"simple"`
	// Represents the warmup duration of Service.
	WarmupDurationSecs *string `field:"optional" json:"warmupDurationSecs" yaml:"warmupDurationSecs"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash struct {
	// Hash based on HTTP cookie.
	HttpCookie *DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie `field:"optional" json:"httpCookie" yaml:"httpCookie"`
	// Hash based on a specific HTTP header.
	HttpHeaderName *string `field:"optional" json:"httpHeaderName" yaml:"httpHeaderName"`
	// Hash based on a specific HTTP query parameter.
	HttpQueryParameterName *string  `field:"optional" json:"httpQueryParameterName" yaml:"httpQueryParameterName"`
	MinimumRingSize        *float64 `field:"optional" json:"minimumRingSize" yaml:"minimumRingSize"`
	// Hash based on the source IP address.
	UseSourceIp *bool `field:"optional" json:"useSourceIp" yaml:"useSourceIp"`
}

// Hash based on HTTP cookie.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie struct {
	// Name of the cookie.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Path to set for the cookie.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Lifetime of the cookie.
	Ttl *string `field:"optional" json:"ttl" yaml:"ttl"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Distribute *[]*DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute `field:"optional" json:"distribute" yaml:"distribute"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	Enabled *bool `field:"optional" json:"enabled" yaml:"enabled"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Failover *[]*DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover `field:"optional" json:"failover" yaml:"failover"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	FailoverPriority *[]*string `field:"optional" json:"failoverPriority" yaml:"failoverPriority"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute struct {
	// Originating locality, '/' separated, e.g.
	From *string `field:"optional" json:"from" yaml:"from"`
	// Map of upstream localities to traffic distribution weights.
	To *map[string]*float64 `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover struct {
	// Originating region.
	From *string `field:"optional" json:"from" yaml:"from"`
	To   *string `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple string

const (
	// UNSPECIFIED.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_UNSPECIFIED DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "UNSPECIFIED"
	// LEAST_CONN.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_LEAST_CONN DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "LEAST_CONN"
	// RANDOM.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_RANDOM DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "RANDOM"
	// PASSTHROUGH.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_PASSTHROUGH DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "PASSTHROUGH"
	// ROUND_ROBIN.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_ROUND_ROBIN DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "ROUND_ROBIN"
	// LEAST_REQUEST.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple_LEAST_REQUEST DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple = "LEAST_REQUEST"
)

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection struct {
	// Minimum ejection duration.
	BaseEjectionTime *string `field:"optional" json:"baseEjectionTime" yaml:"baseEjectionTime"`
	// Number of 5xx errors before a host is ejected from the connection pool.
	Consecutive5XxErrors *float64 `field:"optional" json:"consecutive5XxErrors" yaml:"consecutive5XxErrors"`
	ConsecutiveErrors    *float64 `field:"optional" json:"consecutiveErrors" yaml:"consecutiveErrors"`
	// Number of gateway errors before a host is ejected from the connection pool.
	ConsecutiveGatewayErrors       *float64 `field:"optional" json:"consecutiveGatewayErrors" yaml:"consecutiveGatewayErrors"`
	ConsecutiveLocalOriginFailures *float64 `field:"optional" json:"consecutiveLocalOriginFailures" yaml:"consecutiveLocalOriginFailures"`
	// Time interval between ejection sweep analysis.
	Interval           *string  `field:"optional" json:"interval" yaml:"interval"`
	MaxEjectionPercent *float64 `field:"optional" json:"maxEjectionPercent" yaml:"maxEjectionPercent"`
	MinHealthPercent   *float64 `field:"optional" json:"minHealthPercent" yaml:"minHealthPercent"`
	// Determines whether to distinguish local origin failures from external errors.
	SplitExternalLocalOriginErrors *bool `field:"optional" json:"splitExternalLocalOriginErrors" yaml:"splitExternalLocalOriginErrors"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

// TLS related settings for connections to the upstream service.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls struct {
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// REQUIRED if mode is `MUTUAL`.
	ClientCertificate  *string                                                                `field:"optional" json:"clientCertificate" yaml:"clientCertificate"`
	CredentialName     *string                                                                `field:"optional" json:"credentialName" yaml:"credentialName"`
	InsecureSkipVerify *bool                                                                  `field:"optional" json:"insecureSkipVerify" yaml:"insecureSkipVerify"`
	Mode               DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// SNI string to present to the server during TLS handshake.
	Sni             *string    `field:"optional" json:"sni" yaml:"sni"`
	SubjectAltNames *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode string

const (
	// DISABLE.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode_DISABLE DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode = "DISABLE"
	// SIMPLE.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode_SIMPLE DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode = "SIMPLE"
	// MUTUAL.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode_MUTUAL DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode = "MUTUAL"
	// ISTIO_MUTUAL.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode_ISTIO_MUTUAL DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode = "ISTIO_MUTUAL"
)

// TLS related settings for connections to the upstream service.
type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls struct {
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// REQUIRED if mode is `MUTUAL`.
	ClientCertificate  *string                                               `field:"optional" json:"clientCertificate" yaml:"clientCertificate"`
	CredentialName     *string                                               `field:"optional" json:"credentialName" yaml:"credentialName"`
	InsecureSkipVerify *bool                                                 `field:"optional" json:"insecureSkipVerify" yaml:"insecureSkipVerify"`
	Mode               DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// SNI string to present to the server during TLS handshake.
	Sni             *string    `field:"optional" json:"sni" yaml:"sni"`
	SubjectAltNames *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
}

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode string

const (
	// DISABLE.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode_DISABLE DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode = "DISABLE"
	// SIMPLE.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode_SIMPLE DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode = "SIMPLE"
	// MUTUAL.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode_MUTUAL DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode = "MUTUAL"
	// ISTIO_MUTUAL.
	DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode_ISTIO_MUTUAL DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode = "ISTIO_MUTUAL"
)

type DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel struct {
	// Specifies which protocol to use for tunneling the downstream connection.
	Protocol *string `field:"optional" json:"protocol" yaml:"protocol"`
	// Specifies a host to which the downstream connection is tunneled.
	TargetHost *string `field:"optional" json:"targetHost" yaml:"targetHost"`
	// Specifies a port to which the downstream connection is tunneled.
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

type DestinationRuleV1Beta1SpecTrafficPolicy struct {
	ConnectionPool *DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool `field:"optional" json:"connectionPool" yaml:"connectionPool"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer     *DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer     `field:"optional" json:"loadBalancer" yaml:"loadBalancer"`
	OutlierDetection *DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection `field:"optional" json:"outlierDetection" yaml:"outlierDetection"`
	// Traffic policies specific to individual ports.
	PortLevelSettings *[]*DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings `field:"optional" json:"portLevelSettings" yaml:"portLevelSettings"`
	// TLS related settings for connections to the upstream service.
	Tls    *DestinationRuleV1Beta1SpecTrafficPolicyTls    `field:"optional" json:"tls" yaml:"tls"`
	Tunnel *DestinationRuleV1Beta1SpecTrafficPolicyTunnel `field:"optional" json:"tunnel" yaml:"tunnel"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool struct {
	// HTTP connection pool settings.
	Http *DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp `field:"optional" json:"http" yaml:"http"`
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp `field:"optional" json:"tcp" yaml:"tcp"`
}

// HTTP connection pool settings.
type DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp struct {
	// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
	H2UpgradePolicy         DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy `field:"optional" json:"h2UpgradePolicy" yaml:"h2UpgradePolicy"`
	Http1MaxPendingRequests *float64                                                                 `field:"optional" json:"http1MaxPendingRequests" yaml:"http1MaxPendingRequests"`
	// Maximum number of active requests to a destination.
	Http2MaxRequests *float64 `field:"optional" json:"http2MaxRequests" yaml:"http2MaxRequests"`
	// The idle timeout for upstream connection pool connections.
	IdleTimeout *string `field:"optional" json:"idleTimeout" yaml:"idleTimeout"`
	// Maximum number of requests per connection to a backend.
	MaxRequestsPerConnection *float64 `field:"optional" json:"maxRequestsPerConnection" yaml:"maxRequestsPerConnection"`
	MaxRetries               *float64 `field:"optional" json:"maxRetries" yaml:"maxRetries"`
	// If set to true, client protocol will be preserved while initiating connection to backend.
	UseClientProtocol *bool `field:"optional" json:"useClientProtocol" yaml:"useClientProtocol"`
}

// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
type DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy string

const (
	// DEFAULT.
	DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy_DEFAULT DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "DEFAULT"
	// DO_NOT_UPGRADE.
	DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy_DO_NOT_UPGRADE DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "DO_NOT_UPGRADE"
	// UPGRADE.
	DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy_UPGRADE DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy = "UPGRADE"
)

// Settings common to both HTTP and TCP upstream connections.
type DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp struct {
	// TCP connection timeout.
	ConnectTimeout *string `field:"optional" json:"connectTimeout" yaml:"connectTimeout"`
	// The maximum duration of a connection.
	MaxConnectionDuration *string `field:"optional" json:"maxConnectionDuration" yaml:"maxConnectionDuration"`
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections *float64 `field:"optional" json:"maxConnections" yaml:"maxConnections"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive `field:"optional" json:"tcpKeepalive" yaml:"tcpKeepalive"`
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
type DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive struct {
	// The time duration between keep-alive probes.
	Interval *string  `field:"optional" json:"interval" yaml:"interval"`
	Probes   *float64 `field:"optional" json:"probes" yaml:"probes"`
	Time     *string  `field:"optional" json:"time" yaml:"time"`
}

// Settings controlling the load balancer algorithms.
type DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer struct {
	ConsistentHash    *DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash    `field:"optional" json:"consistentHash" yaml:"consistentHash"`
	LocalityLbSetting *DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting `field:"optional" json:"localityLbSetting" yaml:"localityLbSetting"`
	Simple            DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple             `field:"optional" json:"simple" yaml:"simple"`
	// Represents the warmup duration of Service.
	WarmupDurationSecs *string `field:"optional" json:"warmupDurationSecs" yaml:"warmupDurationSecs"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash struct {
	// Hash based on HTTP cookie.
	HttpCookie *DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie `field:"optional" json:"httpCookie" yaml:"httpCookie"`
	// Hash based on a specific HTTP header.
	HttpHeaderName *string `field:"optional" json:"httpHeaderName" yaml:"httpHeaderName"`
	// Hash based on a specific HTTP query parameter.
	HttpQueryParameterName *string  `field:"optional" json:"httpQueryParameterName" yaml:"httpQueryParameterName"`
	MinimumRingSize        *float64 `field:"optional" json:"minimumRingSize" yaml:"minimumRingSize"`
	// Hash based on the source IP address.
	UseSourceIp *bool `field:"optional" json:"useSourceIp" yaml:"useSourceIp"`
}

// Hash based on HTTP cookie.
type DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie struct {
	// Name of the cookie.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Path to set for the cookie.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Lifetime of the cookie.
	Ttl *string `field:"optional" json:"ttl" yaml:"ttl"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Distribute *[]*DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute `field:"optional" json:"distribute" yaml:"distribute"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	Enabled *bool `field:"optional" json:"enabled" yaml:"enabled"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Failover *[]*DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover `field:"optional" json:"failover" yaml:"failover"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	FailoverPriority *[]*string `field:"optional" json:"failoverPriority" yaml:"failoverPriority"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute struct {
	// Originating locality, '/' separated, e.g.
	From *string `field:"optional" json:"from" yaml:"from"`
	// Map of upstream localities to traffic distribution weights.
	To *map[string]*float64 `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover struct {
	// Originating region.
	From *string `field:"optional" json:"from" yaml:"from"`
	To   *string `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple string

const (
	// UNSPECIFIED.
	DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple_UNSPECIFIED DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple = "UNSPECIFIED"
	// LEAST_CONN.
	DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple_LEAST_CONN DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple = "LEAST_CONN"
	// RANDOM.
	DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple_RANDOM DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple = "RANDOM"
	// PASSTHROUGH.
	DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple_PASSTHROUGH DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple = "PASSTHROUGH"
	// ROUND_ROBIN.
	DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple_ROUND_ROBIN DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple = "ROUND_ROBIN"
	// LEAST_REQUEST.
	DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple_LEAST_REQUEST DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple = "LEAST_REQUEST"
)

type DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection struct {
	// Minimum ejection duration.
	BaseEjectionTime *string `field:"optional" json:"baseEjectionTime" yaml:"baseEjectionTime"`
	// Number of 5xx errors before a host is ejected from the connection pool.
	Consecutive5XxErrors *float64 `field:"optional" json:"consecutive5XxErrors" yaml:"consecutive5XxErrors"`
	ConsecutiveErrors    *float64 `field:"optional" json:"consecutiveErrors" yaml:"consecutiveErrors"`
	// Number of gateway errors before a host is ejected from the connection pool.
	ConsecutiveGatewayErrors       *float64 `field:"optional" json:"consecutiveGatewayErrors" yaml:"consecutiveGatewayErrors"`
	ConsecutiveLocalOriginFailures *float64 `field:"optional" json:"consecutiveLocalOriginFailures" yaml:"consecutiveLocalOriginFailures"`
	// Time interval between ejection sweep analysis.
	Interval           *string  `field:"optional" json:"interval" yaml:"interval"`
	MaxEjectionPercent *float64 `field:"optional" json:"maxEjectionPercent" yaml:"maxEjectionPercent"`
	MinHealthPercent   *float64 `field:"optional" json:"minHealthPercent" yaml:"minHealthPercent"`
	// Determines whether to distinguish local origin failures from external errors.
	SplitExternalLocalOriginErrors *bool `field:"optional" json:"splitExternalLocalOriginErrors" yaml:"splitExternalLocalOriginErrors"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings struct {
	ConnectionPool *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool `field:"optional" json:"connectionPool" yaml:"connectionPool"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer     *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer     `field:"optional" json:"loadBalancer" yaml:"loadBalancer"`
	OutlierDetection *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection `field:"optional" json:"outlierDetection" yaml:"outlierDetection"`
	Port             *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort             `field:"optional" json:"port" yaml:"port"`
	// TLS related settings for connections to the upstream service.
	Tls *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls `field:"optional" json:"tls" yaml:"tls"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool struct {
	// HTTP connection pool settings.
	Http *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp `field:"optional" json:"http" yaml:"http"`
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp `field:"optional" json:"tcp" yaml:"tcp"`
}

// HTTP connection pool settings.
type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp struct {
	// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
	H2UpgradePolicy         DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy `field:"optional" json:"h2UpgradePolicy" yaml:"h2UpgradePolicy"`
	Http1MaxPendingRequests *float64                                                                                  `field:"optional" json:"http1MaxPendingRequests" yaml:"http1MaxPendingRequests"`
	// Maximum number of active requests to a destination.
	Http2MaxRequests *float64 `field:"optional" json:"http2MaxRequests" yaml:"http2MaxRequests"`
	// The idle timeout for upstream connection pool connections.
	IdleTimeout *string `field:"optional" json:"idleTimeout" yaml:"idleTimeout"`
	// Maximum number of requests per connection to a backend.
	MaxRequestsPerConnection *float64 `field:"optional" json:"maxRequestsPerConnection" yaml:"maxRequestsPerConnection"`
	MaxRetries               *float64 `field:"optional" json:"maxRetries" yaml:"maxRetries"`
	// If set to true, client protocol will be preserved while initiating connection to backend.
	UseClientProtocol *bool `field:"optional" json:"useClientProtocol" yaml:"useClientProtocol"`
}

// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy string

const (
	// DEFAULT.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_DEFAULT DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "DEFAULT"
	// DO_NOT_UPGRADE.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_DO_NOT_UPGRADE DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "DO_NOT_UPGRADE"
	// UPGRADE.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy_UPGRADE DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy = "UPGRADE"
)

// Settings common to both HTTP and TCP upstream connections.
type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp struct {
	// TCP connection timeout.
	ConnectTimeout *string `field:"optional" json:"connectTimeout" yaml:"connectTimeout"`
	// The maximum duration of a connection.
	MaxConnectionDuration *string `field:"optional" json:"maxConnectionDuration" yaml:"maxConnectionDuration"`
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections *float64 `field:"optional" json:"maxConnections" yaml:"maxConnections"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive `field:"optional" json:"tcpKeepalive" yaml:"tcpKeepalive"`
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive struct {
	// The time duration between keep-alive probes.
	Interval *string  `field:"optional" json:"interval" yaml:"interval"`
	Probes   *float64 `field:"optional" json:"probes" yaml:"probes"`
	Time     *string  `field:"optional" json:"time" yaml:"time"`
}

// Settings controlling the load balancer algorithms.
type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer struct {
	ConsistentHash    *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash    `field:"optional" json:"consistentHash" yaml:"consistentHash"`
	LocalityLbSetting *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting `field:"optional" json:"localityLbSetting" yaml:"localityLbSetting"`
	Simple            DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple             `field:"optional" json:"simple" yaml:"simple"`
	// Represents the warmup duration of Service.
	WarmupDurationSecs *string `field:"optional" json:"warmupDurationSecs" yaml:"warmupDurationSecs"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash struct {
	// Hash based on HTTP cookie.
	HttpCookie *DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie `field:"optional" json:"httpCookie" yaml:"httpCookie"`
	// Hash based on a specific HTTP header.
	HttpHeaderName *string `field:"optional" json:"httpHeaderName" yaml:"httpHeaderName"`
	// Hash based on a specific HTTP query parameter.
	HttpQueryParameterName *string  `field:"optional" json:"httpQueryParameterName" yaml:"httpQueryParameterName"`
	MinimumRingSize        *float64 `field:"optional" json:"minimumRingSize" yaml:"minimumRingSize"`
	// Hash based on the source IP address.
	UseSourceIp *bool `field:"optional" json:"useSourceIp" yaml:"useSourceIp"`
}

// Hash based on HTTP cookie.
type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie struct {
	// Name of the cookie.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Path to set for the cookie.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Lifetime of the cookie.
	Ttl *string `field:"optional" json:"ttl" yaml:"ttl"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Distribute *[]*DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute `field:"optional" json:"distribute" yaml:"distribute"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	Enabled *bool `field:"optional" json:"enabled" yaml:"enabled"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	Failover *[]*DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover `field:"optional" json:"failover" yaml:"failover"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	FailoverPriority *[]*string `field:"optional" json:"failoverPriority" yaml:"failoverPriority"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute struct {
	// Originating locality, '/' separated, e.g.
	From *string `field:"optional" json:"from" yaml:"from"`
	// Map of upstream localities to traffic distribution weights.
	To *map[string]*float64 `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover struct {
	// Originating region.
	From *string `field:"optional" json:"from" yaml:"from"`
	To   *string `field:"optional" json:"to" yaml:"to"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple string

const (
	// UNSPECIFIED.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_UNSPECIFIED DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "UNSPECIFIED"
	// LEAST_CONN.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_LEAST_CONN DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "LEAST_CONN"
	// RANDOM.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_RANDOM DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "RANDOM"
	// PASSTHROUGH.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_PASSTHROUGH DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "PASSTHROUGH"
	// ROUND_ROBIN.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_ROUND_ROBIN DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "ROUND_ROBIN"
	// LEAST_REQUEST.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple_LEAST_REQUEST DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple = "LEAST_REQUEST"
)

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection struct {
	// Minimum ejection duration.
	BaseEjectionTime *string `field:"optional" json:"baseEjectionTime" yaml:"baseEjectionTime"`
	// Number of 5xx errors before a host is ejected from the connection pool.
	Consecutive5XxErrors *float64 `field:"optional" json:"consecutive5XxErrors" yaml:"consecutive5XxErrors"`
	ConsecutiveErrors    *float64 `field:"optional" json:"consecutiveErrors" yaml:"consecutiveErrors"`
	// Number of gateway errors before a host is ejected from the connection pool.
	ConsecutiveGatewayErrors       *float64 `field:"optional" json:"consecutiveGatewayErrors" yaml:"consecutiveGatewayErrors"`
	ConsecutiveLocalOriginFailures *float64 `field:"optional" json:"consecutiveLocalOriginFailures" yaml:"consecutiveLocalOriginFailures"`
	// Time interval between ejection sweep analysis.
	Interval           *string  `field:"optional" json:"interval" yaml:"interval"`
	MaxEjectionPercent *float64 `field:"optional" json:"maxEjectionPercent" yaml:"maxEjectionPercent"`
	MinHealthPercent   *float64 `field:"optional" json:"minHealthPercent" yaml:"minHealthPercent"`
	// Determines whether to distinguish local origin failures from external errors.
	SplitExternalLocalOriginErrors *bool `field:"optional" json:"splitExternalLocalOriginErrors" yaml:"splitExternalLocalOriginErrors"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

// TLS related settings for connections to the upstream service.
type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls struct {
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// REQUIRED if mode is `MUTUAL`.
	ClientCertificate  *string                                                         `field:"optional" json:"clientCertificate" yaml:"clientCertificate"`
	CredentialName     *string                                                         `field:"optional" json:"credentialName" yaml:"credentialName"`
	InsecureSkipVerify *bool                                                           `field:"optional" json:"insecureSkipVerify" yaml:"insecureSkipVerify"`
	Mode               DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// SNI string to present to the server during TLS handshake.
	Sni             *string    `field:"optional" json:"sni" yaml:"sni"`
	SubjectAltNames *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode string

const (
	// DISABLE.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode_DISABLE DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode = "DISABLE"
	// SIMPLE.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode_SIMPLE DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode = "SIMPLE"
	// MUTUAL.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode_MUTUAL DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode = "MUTUAL"
	// ISTIO_MUTUAL.
	DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode_ISTIO_MUTUAL DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode = "ISTIO_MUTUAL"
)

// TLS related settings for connections to the upstream service.
type DestinationRuleV1Beta1SpecTrafficPolicyTls struct {
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// REQUIRED if mode is `MUTUAL`.
	ClientCertificate  *string                                        `field:"optional" json:"clientCertificate" yaml:"clientCertificate"`
	CredentialName     *string                                        `field:"optional" json:"credentialName" yaml:"credentialName"`
	InsecureSkipVerify *bool                                          `field:"optional" json:"insecureSkipVerify" yaml:"insecureSkipVerify"`
	Mode               DestinationRuleV1Beta1SpecTrafficPolicyTlsMode `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// SNI string to present to the server during TLS handshake.
	Sni             *string    `field:"optional" json:"sni" yaml:"sni"`
	SubjectAltNames *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
}

type DestinationRuleV1Beta1SpecTrafficPolicyTlsMode string

const (
	// DISABLE.
	DestinationRuleV1Beta1SpecTrafficPolicyTlsMode_DISABLE DestinationRuleV1Beta1SpecTrafficPolicyTlsMode = "DISABLE"
	// SIMPLE.
	DestinationRuleV1Beta1SpecTrafficPolicyTlsMode_SIMPLE DestinationRuleV1Beta1SpecTrafficPolicyTlsMode = "SIMPLE"
	// MUTUAL.
	DestinationRuleV1Beta1SpecTrafficPolicyTlsMode_MUTUAL DestinationRuleV1Beta1SpecTrafficPolicyTlsMode = "MUTUAL"
	// ISTIO_MUTUAL.
	DestinationRuleV1Beta1SpecTrafficPolicyTlsMode_ISTIO_MUTUAL DestinationRuleV1Beta1SpecTrafficPolicyTlsMode = "ISTIO_MUTUAL"
)

type DestinationRuleV1Beta1SpecTrafficPolicyTunnel struct {
	// Specifies which protocol to use for tunneling the downstream connection.
	Protocol *string `field:"optional" json:"protocol" yaml:"protocol"`
	// Specifies a host to which the downstream connection is tunneled.
	TargetHost *string `field:"optional" json:"targetHost" yaml:"targetHost"`
	// Specifies a port to which the downstream connection is tunneled.
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

type DestinationRuleV1Beta1SpecWorkloadSelector struct {
	MatchLabels *map[string]*string `field:"optional" json:"matchLabels" yaml:"matchLabels"`
}

type EnvoyFilter interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for EnvoyFilter
type jsiiProxy_EnvoyFilter struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_EnvoyFilter) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_EnvoyFilter) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_EnvoyFilter) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_EnvoyFilter) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_EnvoyFilter) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_EnvoyFilter) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_EnvoyFilter) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "EnvoyFilter" API object.
func NewEnvoyFilter(scope constructs.Construct, id *string, props *EnvoyFilterProps) EnvoyFilter {
	_init_.Initialize()

	j := jsiiProxy_EnvoyFilter{}

	_jsii_.Create(
		"networkingistioio.EnvoyFilter",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "EnvoyFilter" API object.
func NewEnvoyFilter_Override(e EnvoyFilter, scope constructs.Construct, id *string, props *EnvoyFilterProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.EnvoyFilter",
		[]interface{}{scope, id, props},
		e,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func EnvoyFilter_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.EnvoyFilter",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "EnvoyFilter".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func EnvoyFilter_Manifest(props *EnvoyFilterProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.EnvoyFilter",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func EnvoyFilter_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.EnvoyFilter",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func EnvoyFilter_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.EnvoyFilter",
		"GVK",
		&returns,
	)
	return returns
}

func (e *jsiiProxy_EnvoyFilter) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		e,
		"addDependency",
		args,
	)
}

func (e *jsiiProxy_EnvoyFilter) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		e,
		"addJsonPatch",
		args,
	)
}

func (e *jsiiProxy_EnvoyFilter) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		e,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (e *jsiiProxy_EnvoyFilter) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		e,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type EnvoyFilterProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Customizing Envoy configuration generated by Istio.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
	Spec *EnvoyFilterSpec `field:"optional" json:"spec" yaml:"spec"`
}

// Customizing Envoy configuration generated by Istio.
//
// See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
type EnvoyFilterSpec struct {
	// One or more patches with match conditions.
	ConfigPatches *[]*EnvoyFilterSpecConfigPatches `field:"optional" json:"configPatches" yaml:"configPatches"`
	// Priority defines the order in which patch sets are applied within a context.
	Priority         *float64                         `field:"optional" json:"priority" yaml:"priority"`
	WorkloadSelector *EnvoyFilterSpecWorkloadSelector `field:"optional" json:"workloadSelector" yaml:"workloadSelector"`
}

type EnvoyFilterSpecConfigPatches struct {
	ApplyTo EnvoyFilterSpecConfigPatchesApplyTo `field:"optional" json:"applyTo" yaml:"applyTo"`
	// Match on listener/route configuration/cluster.
	Match *EnvoyFilterSpecConfigPatchesMatch `field:"optional" json:"match" yaml:"match"`
	// The patch to apply along with the operation.
	Patch *EnvoyFilterSpecConfigPatchesPatch `field:"optional" json:"patch" yaml:"patch"`
}

type EnvoyFilterSpecConfigPatchesApplyTo string

const (
	// INVALID.
	EnvoyFilterSpecConfigPatchesApplyTo_INVALID EnvoyFilterSpecConfigPatchesApplyTo = "INVALID"
	// LISTENER.
	EnvoyFilterSpecConfigPatchesApplyTo_LISTENER EnvoyFilterSpecConfigPatchesApplyTo = "LISTENER"
	// FILTER_CHAIN.
	EnvoyFilterSpecConfigPatchesApplyTo_FILTER_CHAIN EnvoyFilterSpecConfigPatchesApplyTo = "FILTER_CHAIN"
	// NETWORK_FILTER.
	EnvoyFilterSpecConfigPatchesApplyTo_NETWORK_FILTER EnvoyFilterSpecConfigPatchesApplyTo = "NETWORK_FILTER"
	// HTTP_FILTER.
	EnvoyFilterSpecConfigPatchesApplyTo_HTTP_FILTER EnvoyFilterSpecConfigPatchesApplyTo = "HTTP_FILTER"
	// ROUTE_CONFIGURATION.
	EnvoyFilterSpecConfigPatchesApplyTo_ROUTE_CONFIGURATION EnvoyFilterSpecConfigPatchesApplyTo = "ROUTE_CONFIGURATION"
	// VIRTUAL_HOST.
	EnvoyFilterSpecConfigPatchesApplyTo_VIRTUAL_HOST EnvoyFilterSpecConfigPatchesApplyTo = "VIRTUAL_HOST"
	// HTTP_ROUTE.
	EnvoyFilterSpecConfigPatchesApplyTo_HTTP_ROUTE EnvoyFilterSpecConfigPatchesApplyTo = "HTTP_ROUTE"
	// CLUSTER.
	EnvoyFilterSpecConfigPatchesApplyTo_CLUSTER EnvoyFilterSpecConfigPatchesApplyTo = "CLUSTER"
	// EXTENSION_CONFIG.
	EnvoyFilterSpecConfigPatchesApplyTo_EXTENSION_CONFIG EnvoyFilterSpecConfigPatchesApplyTo = "EXTENSION_CONFIG"
	// BOOTSTRAP.
	EnvoyFilterSpecConfigPatchesApplyTo_BOOTSTRAP EnvoyFilterSpecConfigPatchesApplyTo = "BOOTSTRAP"
)

// Match on listener/route configuration/cluster.
type EnvoyFilterSpecConfigPatchesMatch struct {
	// Match on envoy cluster attributes.
	Cluster *EnvoyFilterSpecConfigPatchesMatchCluster `field:"optional" json:"cluster" yaml:"cluster"`
	// The specific config generation context to match on.
	Context EnvoyFilterSpecConfigPatchesMatchContext `field:"optional" json:"context" yaml:"context"`
	// Match on envoy listener attributes.
	Listener *EnvoyFilterSpecConfigPatchesMatchListener `field:"optional" json:"listener" yaml:"listener"`
	// Match on properties associated with a proxy.
	Proxy *EnvoyFilterSpecConfigPatchesMatchProxy `field:"optional" json:"proxy" yaml:"proxy"`
	// Match on envoy HTTP route configuration attributes.
	RouteConfiguration *EnvoyFilterSpecConfigPatchesMatchRouteConfiguration `field:"optional" json:"routeConfiguration" yaml:"routeConfiguration"`
}

// Match on envoy cluster attributes.
type EnvoyFilterSpecConfigPatchesMatchCluster struct {
	// The exact name of the cluster to match.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// The service port for which this cluster was generated.
	PortNumber *float64 `field:"optional" json:"portNumber" yaml:"portNumber"`
	// The fully qualified service name for this cluster.
	Service *string `field:"optional" json:"service" yaml:"service"`
	// The subset associated with the service.
	Subset *string `field:"optional" json:"subset" yaml:"subset"`
}

// The specific config generation context to match on.
type EnvoyFilterSpecConfigPatchesMatchContext string

const (
	// ANY.
	EnvoyFilterSpecConfigPatchesMatchContext_ANY EnvoyFilterSpecConfigPatchesMatchContext = "ANY"
	// SIDECAR_INBOUND.
	EnvoyFilterSpecConfigPatchesMatchContext_SIDECAR_INBOUND EnvoyFilterSpecConfigPatchesMatchContext = "SIDECAR_INBOUND"
	// SIDECAR_OUTBOUND.
	EnvoyFilterSpecConfigPatchesMatchContext_SIDECAR_OUTBOUND EnvoyFilterSpecConfigPatchesMatchContext = "SIDECAR_OUTBOUND"
	// GATEWAY.
	EnvoyFilterSpecConfigPatchesMatchContext_GATEWAY EnvoyFilterSpecConfigPatchesMatchContext = "GATEWAY"
)

// Match on envoy listener attributes.
type EnvoyFilterSpecConfigPatchesMatchListener struct {
	// Match a specific filter chain in a listener.
	FilterChain *EnvoyFilterSpecConfigPatchesMatchListenerFilterChain `field:"optional" json:"filterChain" yaml:"filterChain"`
	// Match a specific listener by its name.
	Name       *string  `field:"optional" json:"name" yaml:"name"`
	PortName   *string  `field:"optional" json:"portName" yaml:"portName"`
	PortNumber *float64 `field:"optional" json:"portNumber" yaml:"portNumber"`
}

// Match a specific filter chain in a listener.
type EnvoyFilterSpecConfigPatchesMatchListenerFilterChain struct {
	// Applies only to sidecars.
	ApplicationProtocols *string `field:"optional" json:"applicationProtocols" yaml:"applicationProtocols"`
	// The destination_port value used by a filter chain's match condition.
	DestinationPort *float64 `field:"optional" json:"destinationPort" yaml:"destinationPort"`
	// The name of a specific filter to apply the patch to.
	Filter *EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter `field:"optional" json:"filter" yaml:"filter"`
	// The name assigned to the filter chain.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// The SNI value used by a filter chain's match condition.
	Sni *string `field:"optional" json:"sni" yaml:"sni"`
	// Applies only to `SIDECAR_INBOUND` context.
	TransportProtocol *string `field:"optional" json:"transportProtocol" yaml:"transportProtocol"`
}

// The name of a specific filter to apply the patch to.
type EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter struct {
	// The filter name to match on.
	Name      *string                                                              `field:"optional" json:"name" yaml:"name"`
	SubFilter *EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter `field:"optional" json:"subFilter" yaml:"subFilter"`
}

type EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter struct {
	// The filter name to match on.
	Name *string `field:"optional" json:"name" yaml:"name"`
}

// Match on properties associated with a proxy.
type EnvoyFilterSpecConfigPatchesMatchProxy struct {
	Metadata     *map[string]*string `field:"optional" json:"metadata" yaml:"metadata"`
	ProxyVersion *string             `field:"optional" json:"proxyVersion" yaml:"proxyVersion"`
}

// Match on envoy HTTP route configuration attributes.
type EnvoyFilterSpecConfigPatchesMatchRouteConfiguration struct {
	Gateway *string `field:"optional" json:"gateway" yaml:"gateway"`
	// Route configuration name to match on.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Applicable only for GATEWAY context.
	PortName   *string                                                   `field:"optional" json:"portName" yaml:"portName"`
	PortNumber *float64                                                  `field:"optional" json:"portNumber" yaml:"portNumber"`
	Vhost      *EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost `field:"optional" json:"vhost" yaml:"vhost"`
}

type EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost struct {
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Match a specific route within the virtual host.
	Route *EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute `field:"optional" json:"route" yaml:"route"`
}

// Match a specific route within the virtual host.
type EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute struct {
	// Match a route with specific action type.
	Action EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction `field:"optional" json:"action" yaml:"action"`
	Name   *string                                                             `field:"optional" json:"name" yaml:"name"`
}

// Match a route with specific action type.
type EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction string

const (
	// ANY.
	EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction_ANY EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction = "ANY"
	// ROUTE.
	EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction_ROUTE EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction = "ROUTE"
	// REDIRECT.
	EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction_REDIRECT EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction = "REDIRECT"
	// DIRECT_RESPONSE.
	EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction_DIRECT_RESPONSE EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction = "DIRECT_RESPONSE"
)

// The patch to apply along with the operation.
type EnvoyFilterSpecConfigPatchesPatch struct {
	// Determines the filter insertion order.
	FilterClass EnvoyFilterSpecConfigPatchesPatchFilterClass `field:"optional" json:"filterClass" yaml:"filterClass"`
	// Determines how the patch should be applied.
	Operation EnvoyFilterSpecConfigPatchesPatchOperation `field:"optional" json:"operation" yaml:"operation"`
	// The JSON config of the object being patched.
	Value interface{} `field:"optional" json:"value" yaml:"value"`
}

// Determines the filter insertion order.
type EnvoyFilterSpecConfigPatchesPatchFilterClass string

const (
	// UNSPECIFIED.
	EnvoyFilterSpecConfigPatchesPatchFilterClass_UNSPECIFIED EnvoyFilterSpecConfigPatchesPatchFilterClass = "UNSPECIFIED"
	// AUTHN.
	EnvoyFilterSpecConfigPatchesPatchFilterClass_AUTHN EnvoyFilterSpecConfigPatchesPatchFilterClass = "AUTHN"
	// AUTHZ.
	EnvoyFilterSpecConfigPatchesPatchFilterClass_AUTHZ EnvoyFilterSpecConfigPatchesPatchFilterClass = "AUTHZ"
	// STATS.
	EnvoyFilterSpecConfigPatchesPatchFilterClass_STATS EnvoyFilterSpecConfigPatchesPatchFilterClass = "STATS"
)

// Determines how the patch should be applied.
type EnvoyFilterSpecConfigPatchesPatchOperation string

const (
	// INVALID.
	EnvoyFilterSpecConfigPatchesPatchOperation_INVALID EnvoyFilterSpecConfigPatchesPatchOperation = "INVALID"
	// MERGE.
	EnvoyFilterSpecConfigPatchesPatchOperation_MERGE EnvoyFilterSpecConfigPatchesPatchOperation = "MERGE"
	// ADD.
	EnvoyFilterSpecConfigPatchesPatchOperation_ADD EnvoyFilterSpecConfigPatchesPatchOperation = "ADD"
	// REMOVE.
	EnvoyFilterSpecConfigPatchesPatchOperation_REMOVE EnvoyFilterSpecConfigPatchesPatchOperation = "REMOVE"
	// INSERT_BEFORE.
	EnvoyFilterSpecConfigPatchesPatchOperation_INSERT_BEFORE EnvoyFilterSpecConfigPatchesPatchOperation = "INSERT_BEFORE"
	// INSERT_AFTER.
	EnvoyFilterSpecConfigPatchesPatchOperation_INSERT_AFTER EnvoyFilterSpecConfigPatchesPatchOperation = "INSERT_AFTER"
	// INSERT_FIRST.
	EnvoyFilterSpecConfigPatchesPatchOperation_INSERT_FIRST EnvoyFilterSpecConfigPatchesPatchOperation = "INSERT_FIRST"
	// REPLACE.
	EnvoyFilterSpecConfigPatchesPatchOperation_REPLACE EnvoyFilterSpecConfigPatchesPatchOperation = "REPLACE"
)

type EnvoyFilterSpecWorkloadSelector struct {
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
}

type Gateway interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for Gateway
type jsiiProxy_Gateway struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_Gateway) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Gateway) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Gateway) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Gateway) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Gateway) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Gateway) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Gateway) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "Gateway" API object.
func NewGateway(scope constructs.Construct, id *string, props *GatewayProps) Gateway {
	_init_.Initialize()

	j := jsiiProxy_Gateway{}

	_jsii_.Create(
		"networkingistioio.Gateway",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "Gateway" API object.
func NewGateway_Override(g Gateway, scope constructs.Construct, id *string, props *GatewayProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.Gateway",
		[]interface{}{scope, id, props},
		g,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func Gateway_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.Gateway",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "Gateway".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func Gateway_Manifest(props *GatewayProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.Gateway",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func Gateway_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.Gateway",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func Gateway_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.Gateway",
		"GVK",
		&returns,
	)
	return returns
}

func (g *jsiiProxy_Gateway) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		g,
		"addDependency",
		args,
	)
}

func (g *jsiiProxy_Gateway) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		g,
		"addJsonPatch",
		args,
	)
}

func (g *jsiiProxy_Gateway) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		g,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (g *jsiiProxy_Gateway) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		g,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type GatewayProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting edge load balancer.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/gateway.html
	Spec *GatewaySpec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting edge load balancer.
//
// See more details at: https://istio.io/docs/reference/config/networking/gateway.html
type GatewaySpec struct {
	Selector *map[string]*string `field:"optional" json:"selector" yaml:"selector"`
	// A list of server specifications.
	Servers *[]*GatewaySpecServers `field:"optional" json:"servers" yaml:"servers"`
}

type GatewaySpecServers struct {
	Bind            *string `field:"optional" json:"bind" yaml:"bind"`
	DefaultEndpoint *string `field:"optional" json:"defaultEndpoint" yaml:"defaultEndpoint"`
	// One or more hosts exposed by this gateway.
	Hosts *[]*string `field:"optional" json:"hosts" yaml:"hosts"`
	// An optional name of the server, when set must be unique across all servers.
	Name *string                 `field:"optional" json:"name" yaml:"name"`
	Port *GatewaySpecServersPort `field:"optional" json:"port" yaml:"port"`
	// Set of TLS related options that govern the server's behavior.
	Tls *GatewaySpecServersTls `field:"optional" json:"tls" yaml:"tls"`
}

type GatewaySpecServersPort struct {
	// Label assigned to the port.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A valid non-negative integer port number.
	Number *float64 `field:"optional" json:"number" yaml:"number"`
	// The protocol exposed on the port.
	Protocol   *string  `field:"optional" json:"protocol" yaml:"protocol"`
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

// Set of TLS related options that govern the server's behavior.
type GatewaySpecServersTls struct {
	// REQUIRED if mode is `MUTUAL`.
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// Optional: If specified, only support the specified cipher list.
	CipherSuites   *[]*string `field:"optional" json:"cipherSuites" yaml:"cipherSuites"`
	CredentialName *string    `field:"optional" json:"credentialName" yaml:"credentialName"`
	HttpsRedirect  *bool      `field:"optional" json:"httpsRedirect" yaml:"httpsRedirect"`
	// Optional: Maximum TLS protocol version.
	MaxProtocolVersion GatewaySpecServersTlsMaxProtocolVersion `field:"optional" json:"maxProtocolVersion" yaml:"maxProtocolVersion"`
	// Optional: Minimum TLS protocol version.
	MinProtocolVersion GatewaySpecServersTlsMinProtocolVersion `field:"optional" json:"minProtocolVersion" yaml:"minProtocolVersion"`
	Mode               GatewaySpecServersTlsMode               `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
	ServerCertificate     *string    `field:"optional" json:"serverCertificate" yaml:"serverCertificate"`
	SubjectAltNames       *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
	VerifyCertificateHash *[]*string `field:"optional" json:"verifyCertificateHash" yaml:"verifyCertificateHash"`
	VerifyCertificateSpki *[]*string `field:"optional" json:"verifyCertificateSpki" yaml:"verifyCertificateSpki"`
}

// Optional: Maximum TLS protocol version.
type GatewaySpecServersTlsMaxProtocolVersion string

const (
	// TLS_AUTO.
	GatewaySpecServersTlsMaxProtocolVersion_TLS_AUTO GatewaySpecServersTlsMaxProtocolVersion = "TLS_AUTO"
	// TLSV1_0.
	GatewaySpecServersTlsMaxProtocolVersion_TLSV1_0 GatewaySpecServersTlsMaxProtocolVersion = "TLSV1_0"
	// TLSV1_1.
	GatewaySpecServersTlsMaxProtocolVersion_TLSV1_1 GatewaySpecServersTlsMaxProtocolVersion = "TLSV1_1"
	// TLSV1_2.
	GatewaySpecServersTlsMaxProtocolVersion_TLSV1_2 GatewaySpecServersTlsMaxProtocolVersion = "TLSV1_2"
	// TLSV1_3.
	GatewaySpecServersTlsMaxProtocolVersion_TLSV1_3 GatewaySpecServersTlsMaxProtocolVersion = "TLSV1_3"
)

// Optional: Minimum TLS protocol version.
type GatewaySpecServersTlsMinProtocolVersion string

const (
	// TLS_AUTO.
	GatewaySpecServersTlsMinProtocolVersion_TLS_AUTO GatewaySpecServersTlsMinProtocolVersion = "TLS_AUTO"
	// TLSV1_0.
	GatewaySpecServersTlsMinProtocolVersion_TLSV1_0 GatewaySpecServersTlsMinProtocolVersion = "TLSV1_0"
	// TLSV1_1.
	GatewaySpecServersTlsMinProtocolVersion_TLSV1_1 GatewaySpecServersTlsMinProtocolVersion = "TLSV1_1"
	// TLSV1_2.
	GatewaySpecServersTlsMinProtocolVersion_TLSV1_2 GatewaySpecServersTlsMinProtocolVersion = "TLSV1_2"
	// TLSV1_3.
	GatewaySpecServersTlsMinProtocolVersion_TLSV1_3 GatewaySpecServersTlsMinProtocolVersion = "TLSV1_3"
)

type GatewaySpecServersTlsMode string

const (
	// PASSTHROUGH.
	GatewaySpecServersTlsMode_PASSTHROUGH GatewaySpecServersTlsMode = "PASSTHROUGH"
	// SIMPLE.
	GatewaySpecServersTlsMode_SIMPLE GatewaySpecServersTlsMode = "SIMPLE"
	// MUTUAL.
	GatewaySpecServersTlsMode_MUTUAL GatewaySpecServersTlsMode = "MUTUAL"
	// AUTO_PASSTHROUGH.
	GatewaySpecServersTlsMode_AUTO_PASSTHROUGH GatewaySpecServersTlsMode = "AUTO_PASSTHROUGH"
	// ISTIO_MUTUAL.
	GatewaySpecServersTlsMode_ISTIO_MUTUAL GatewaySpecServersTlsMode = "ISTIO_MUTUAL"
)

type GatewayV1Beta1 interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for GatewayV1Beta1
type jsiiProxy_GatewayV1Beta1 struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_GatewayV1Beta1) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_GatewayV1Beta1) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_GatewayV1Beta1) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_GatewayV1Beta1) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_GatewayV1Beta1) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_GatewayV1Beta1) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_GatewayV1Beta1) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "GatewayV1Beta1" API object.
func NewGatewayV1Beta1(scope constructs.Construct, id *string, props *GatewayV1Beta1Props) GatewayV1Beta1 {
	_init_.Initialize()

	j := jsiiProxy_GatewayV1Beta1{}

	_jsii_.Create(
		"networkingistioio.GatewayV1Beta1",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "GatewayV1Beta1" API object.
func NewGatewayV1Beta1_Override(g GatewayV1Beta1, scope constructs.Construct, id *string, props *GatewayV1Beta1Props) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.GatewayV1Beta1",
		[]interface{}{scope, id, props},
		g,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func GatewayV1Beta1_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.GatewayV1Beta1",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "GatewayV1Beta1".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func GatewayV1Beta1_Manifest(props *GatewayV1Beta1Props) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.GatewayV1Beta1",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func GatewayV1Beta1_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.GatewayV1Beta1",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func GatewayV1Beta1_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.GatewayV1Beta1",
		"GVK",
		&returns,
	)
	return returns
}

func (g *jsiiProxy_GatewayV1Beta1) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		g,
		"addDependency",
		args,
	)
}

func (g *jsiiProxy_GatewayV1Beta1) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		g,
		"addJsonPatch",
		args,
	)
}

func (g *jsiiProxy_GatewayV1Beta1) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		g,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (g *jsiiProxy_GatewayV1Beta1) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		g,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type GatewayV1Beta1Props struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting edge load balancer.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/gateway.html
	Spec *GatewayV1Beta1Spec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting edge load balancer.
//
// See more details at: https://istio.io/docs/reference/config/networking/gateway.html
type GatewayV1Beta1Spec struct {
	Selector *map[string]*string `field:"optional" json:"selector" yaml:"selector"`
	// A list of server specifications.
	Servers *[]*GatewayV1Beta1SpecServers `field:"optional" json:"servers" yaml:"servers"`
}

type GatewayV1Beta1SpecServers struct {
	Bind            *string `field:"optional" json:"bind" yaml:"bind"`
	DefaultEndpoint *string `field:"optional" json:"defaultEndpoint" yaml:"defaultEndpoint"`
	// One or more hosts exposed by this gateway.
	Hosts *[]*string `field:"optional" json:"hosts" yaml:"hosts"`
	// An optional name of the server, when set must be unique across all servers.
	Name *string                        `field:"optional" json:"name" yaml:"name"`
	Port *GatewayV1Beta1SpecServersPort `field:"optional" json:"port" yaml:"port"`
	// Set of TLS related options that govern the server's behavior.
	Tls *GatewayV1Beta1SpecServersTls `field:"optional" json:"tls" yaml:"tls"`
}

type GatewayV1Beta1SpecServersPort struct {
	// Label assigned to the port.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A valid non-negative integer port number.
	Number *float64 `field:"optional" json:"number" yaml:"number"`
	// The protocol exposed on the port.
	Protocol   *string  `field:"optional" json:"protocol" yaml:"protocol"`
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

// Set of TLS related options that govern the server's behavior.
type GatewayV1Beta1SpecServersTls struct {
	// REQUIRED if mode is `MUTUAL`.
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// Optional: If specified, only support the specified cipher list.
	CipherSuites   *[]*string `field:"optional" json:"cipherSuites" yaml:"cipherSuites"`
	CredentialName *string    `field:"optional" json:"credentialName" yaml:"credentialName"`
	HttpsRedirect  *bool      `field:"optional" json:"httpsRedirect" yaml:"httpsRedirect"`
	// Optional: Maximum TLS protocol version.
	MaxProtocolVersion GatewayV1Beta1SpecServersTlsMaxProtocolVersion `field:"optional" json:"maxProtocolVersion" yaml:"maxProtocolVersion"`
	// Optional: Minimum TLS protocol version.
	MinProtocolVersion GatewayV1Beta1SpecServersTlsMinProtocolVersion `field:"optional" json:"minProtocolVersion" yaml:"minProtocolVersion"`
	Mode               GatewayV1Beta1SpecServersTlsMode               `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
	ServerCertificate     *string    `field:"optional" json:"serverCertificate" yaml:"serverCertificate"`
	SubjectAltNames       *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
	VerifyCertificateHash *[]*string `field:"optional" json:"verifyCertificateHash" yaml:"verifyCertificateHash"`
	VerifyCertificateSpki *[]*string `field:"optional" json:"verifyCertificateSpki" yaml:"verifyCertificateSpki"`
}

// Optional: Maximum TLS protocol version.
type GatewayV1Beta1SpecServersTlsMaxProtocolVersion string

const (
	// TLS_AUTO.
	GatewayV1Beta1SpecServersTlsMaxProtocolVersion_TLS_AUTO GatewayV1Beta1SpecServersTlsMaxProtocolVersion = "TLS_AUTO"
	// TLSV1_0.
	GatewayV1Beta1SpecServersTlsMaxProtocolVersion_TLSV1_0 GatewayV1Beta1SpecServersTlsMaxProtocolVersion = "TLSV1_0"
	// TLSV1_1.
	GatewayV1Beta1SpecServersTlsMaxProtocolVersion_TLSV1_1 GatewayV1Beta1SpecServersTlsMaxProtocolVersion = "TLSV1_1"
	// TLSV1_2.
	GatewayV1Beta1SpecServersTlsMaxProtocolVersion_TLSV1_2 GatewayV1Beta1SpecServersTlsMaxProtocolVersion = "TLSV1_2"
	// TLSV1_3.
	GatewayV1Beta1SpecServersTlsMaxProtocolVersion_TLSV1_3 GatewayV1Beta1SpecServersTlsMaxProtocolVersion = "TLSV1_3"
)

// Optional: Minimum TLS protocol version.
type GatewayV1Beta1SpecServersTlsMinProtocolVersion string

const (
	// TLS_AUTO.
	GatewayV1Beta1SpecServersTlsMinProtocolVersion_TLS_AUTO GatewayV1Beta1SpecServersTlsMinProtocolVersion = "TLS_AUTO"
	// TLSV1_0.
	GatewayV1Beta1SpecServersTlsMinProtocolVersion_TLSV1_0 GatewayV1Beta1SpecServersTlsMinProtocolVersion = "TLSV1_0"
	// TLSV1_1.
	GatewayV1Beta1SpecServersTlsMinProtocolVersion_TLSV1_1 GatewayV1Beta1SpecServersTlsMinProtocolVersion = "TLSV1_1"
	// TLSV1_2.
	GatewayV1Beta1SpecServersTlsMinProtocolVersion_TLSV1_2 GatewayV1Beta1SpecServersTlsMinProtocolVersion = "TLSV1_2"
	// TLSV1_3.
	GatewayV1Beta1SpecServersTlsMinProtocolVersion_TLSV1_3 GatewayV1Beta1SpecServersTlsMinProtocolVersion = "TLSV1_3"
)

type GatewayV1Beta1SpecServersTlsMode string

const (
	// PASSTHROUGH.
	GatewayV1Beta1SpecServersTlsMode_PASSTHROUGH GatewayV1Beta1SpecServersTlsMode = "PASSTHROUGH"
	// SIMPLE.
	GatewayV1Beta1SpecServersTlsMode_SIMPLE GatewayV1Beta1SpecServersTlsMode = "SIMPLE"
	// MUTUAL.
	GatewayV1Beta1SpecServersTlsMode_MUTUAL GatewayV1Beta1SpecServersTlsMode = "MUTUAL"
	// AUTO_PASSTHROUGH.
	GatewayV1Beta1SpecServersTlsMode_AUTO_PASSTHROUGH GatewayV1Beta1SpecServersTlsMode = "AUTO_PASSTHROUGH"
	// ISTIO_MUTUAL.
	GatewayV1Beta1SpecServersTlsMode_ISTIO_MUTUAL GatewayV1Beta1SpecServersTlsMode = "ISTIO_MUTUAL"
)

type ProxyConfig interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for ProxyConfig
type jsiiProxy_ProxyConfig struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_ProxyConfig) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ProxyConfig) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ProxyConfig) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ProxyConfig) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ProxyConfig) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ProxyConfig) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ProxyConfig) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "ProxyConfig" API object.
func NewProxyConfig(scope constructs.Construct, id *string, props *ProxyConfigProps) ProxyConfig {
	_init_.Initialize()

	j := jsiiProxy_ProxyConfig{}

	_jsii_.Create(
		"networkingistioio.ProxyConfig",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "ProxyConfig" API object.
func NewProxyConfig_Override(p ProxyConfig, scope constructs.Construct, id *string, props *ProxyConfigProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.ProxyConfig",
		[]interface{}{scope, id, props},
		p,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func ProxyConfig_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.ProxyConfig",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "ProxyConfig".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func ProxyConfig_Manifest(props *ProxyConfigProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.ProxyConfig",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func ProxyConfig_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.ProxyConfig",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func ProxyConfig_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.ProxyConfig",
		"GVK",
		&returns,
	)
	return returns
}

func (p *jsiiProxy_ProxyConfig) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		p,
		"addDependency",
		args,
	)
}

func (p *jsiiProxy_ProxyConfig) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		p,
		"addJsonPatch",
		args,
	)
}

func (p *jsiiProxy_ProxyConfig) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		p,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (p *jsiiProxy_ProxyConfig) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		p,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type ProxyConfigProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Provides configuration for individual workloads.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
	Spec *ProxyConfigSpec `field:"optional" json:"spec" yaml:"spec"`
}

// Provides configuration for individual workloads.
//
// See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
type ProxyConfigSpec struct {
	// The number of worker threads to run.
	Concurrency *float64 `field:"optional" json:"concurrency" yaml:"concurrency"`
	// Additional environment variables for the proxy.
	EnvironmentVariables *map[string]*string `field:"optional" json:"environmentVariables" yaml:"environmentVariables"`
	// Specifies the details of the proxy image.
	Image *ProxyConfigSpecImage `field:"optional" json:"image" yaml:"image"`
	// Optional.
	Selector *ProxyConfigSpecSelector `field:"optional" json:"selector" yaml:"selector"`
}

// Specifies the details of the proxy image.
type ProxyConfigSpecImage struct {
	// The image type of the image.
	ImageType *string `field:"optional" json:"imageType" yaml:"imageType"`
}

// Optional.
type ProxyConfigSpecSelector struct {
	MatchLabels *map[string]*string `field:"optional" json:"matchLabels" yaml:"matchLabels"`
}

type ServiceEntry interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for ServiceEntry
type jsiiProxy_ServiceEntry struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_ServiceEntry) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntry) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntry) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntry) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntry) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntry) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntry) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "ServiceEntry" API object.
func NewServiceEntry(scope constructs.Construct, id *string, props *ServiceEntryProps) ServiceEntry {
	_init_.Initialize()

	j := jsiiProxy_ServiceEntry{}

	_jsii_.Create(
		"networkingistioio.ServiceEntry",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "ServiceEntry" API object.
func NewServiceEntry_Override(s ServiceEntry, scope constructs.Construct, id *string, props *ServiceEntryProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.ServiceEntry",
		[]interface{}{scope, id, props},
		s,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func ServiceEntry_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.ServiceEntry",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "ServiceEntry".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func ServiceEntry_Manifest(props *ServiceEntryProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.ServiceEntry",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func ServiceEntry_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.ServiceEntry",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func ServiceEntry_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.ServiceEntry",
		"GVK",
		&returns,
	)
	return returns
}

func (s *jsiiProxy_ServiceEntry) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addDependency",
		args,
	)
}

func (s *jsiiProxy_ServiceEntry) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addJsonPatch",
		args,
	)
}

func (s *jsiiProxy_ServiceEntry) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		s,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (s *jsiiProxy_ServiceEntry) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		s,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type ServiceEntryProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting service registry.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
	Spec *ServiceEntrySpec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting service registry.
//
// See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
type ServiceEntrySpec struct {
	// The virtual IP addresses associated with the service.
	Addresses *[]*string `field:"optional" json:"addresses" yaml:"addresses"`
	// One or more endpoints associated with the service.
	Endpoints *[]*ServiceEntrySpecEndpoints `field:"optional" json:"endpoints" yaml:"endpoints"`
	// A list of namespaces to which this service is exported.
	ExportTo *[]*string `field:"optional" json:"exportTo" yaml:"exportTo"`
	// The hosts associated with the ServiceEntry.
	Hosts    *[]*string               `field:"optional" json:"hosts" yaml:"hosts"`
	Location ServiceEntrySpecLocation `field:"optional" json:"location" yaml:"location"`
	// The ports associated with the external service.
	Ports *[]*ServiceEntrySpecPorts `field:"optional" json:"ports" yaml:"ports"`
	// Service discovery mode for the hosts.
	Resolution      ServiceEntrySpecResolution `field:"optional" json:"resolution" yaml:"resolution"`
	SubjectAltNames *[]*string                 `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
	// Applicable only for MESH_INTERNAL services.
	WorkloadSelector *ServiceEntrySpecWorkloadSelector `field:"optional" json:"workloadSelector" yaml:"workloadSelector"`
}

type ServiceEntrySpecEndpoints struct {
	Address *string `field:"optional" json:"address" yaml:"address"`
	// One or more labels associated with the endpoint.
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
	// The locality associated with the endpoint.
	Locality *string `field:"optional" json:"locality" yaml:"locality"`
	Network  *string `field:"optional" json:"network" yaml:"network"`
	// Set of ports associated with the endpoint.
	Ports          *map[string]*float64 `field:"optional" json:"ports" yaml:"ports"`
	ServiceAccount *string              `field:"optional" json:"serviceAccount" yaml:"serviceAccount"`
	// The load balancing weight associated with the endpoint.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}

type ServiceEntrySpecLocation string

const (
	// MESH_EXTERNAL.
	ServiceEntrySpecLocation_MESH_EXTERNAL ServiceEntrySpecLocation = "MESH_EXTERNAL"
	// MESH_INTERNAL.
	ServiceEntrySpecLocation_MESH_INTERNAL ServiceEntrySpecLocation = "MESH_INTERNAL"
)

type ServiceEntrySpecPorts struct {
	// Label assigned to the port.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A valid non-negative integer port number.
	Number *float64 `field:"optional" json:"number" yaml:"number"`
	// The protocol exposed on the port.
	Protocol   *string  `field:"optional" json:"protocol" yaml:"protocol"`
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

// Service discovery mode for the hosts.
type ServiceEntrySpecResolution string

const (
	// NONE.
	ServiceEntrySpecResolution_NONE ServiceEntrySpecResolution = "NONE"
	// STATIC.
	ServiceEntrySpecResolution_STATIC ServiceEntrySpecResolution = "STATIC"
	// DNS.
	ServiceEntrySpecResolution_DNS ServiceEntrySpecResolution = "DNS"
	// DNS_ROUND_ROBIN.
	ServiceEntrySpecResolution_DNS_ROUND_ROBIN ServiceEntrySpecResolution = "DNS_ROUND_ROBIN"
)

// Applicable only for MESH_INTERNAL services.
type ServiceEntrySpecWorkloadSelector struct {
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
}

type ServiceEntryV1Beta1 interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for ServiceEntryV1Beta1
type jsiiProxy_ServiceEntryV1Beta1 struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_ServiceEntryV1Beta1) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntryV1Beta1) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntryV1Beta1) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntryV1Beta1) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntryV1Beta1) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntryV1Beta1) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_ServiceEntryV1Beta1) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "ServiceEntryV1Beta1" API object.
func NewServiceEntryV1Beta1(scope constructs.Construct, id *string, props *ServiceEntryV1Beta1Props) ServiceEntryV1Beta1 {
	_init_.Initialize()

	j := jsiiProxy_ServiceEntryV1Beta1{}

	_jsii_.Create(
		"networkingistioio.ServiceEntryV1Beta1",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "ServiceEntryV1Beta1" API object.
func NewServiceEntryV1Beta1_Override(s ServiceEntryV1Beta1, scope constructs.Construct, id *string, props *ServiceEntryV1Beta1Props) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.ServiceEntryV1Beta1",
		[]interface{}{scope, id, props},
		s,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func ServiceEntryV1Beta1_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.ServiceEntryV1Beta1",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "ServiceEntryV1Beta1".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func ServiceEntryV1Beta1_Manifest(props *ServiceEntryV1Beta1Props) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.ServiceEntryV1Beta1",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func ServiceEntryV1Beta1_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.ServiceEntryV1Beta1",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func ServiceEntryV1Beta1_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.ServiceEntryV1Beta1",
		"GVK",
		&returns,
	)
	return returns
}

func (s *jsiiProxy_ServiceEntryV1Beta1) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addDependency",
		args,
	)
}

func (s *jsiiProxy_ServiceEntryV1Beta1) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addJsonPatch",
		args,
	)
}

func (s *jsiiProxy_ServiceEntryV1Beta1) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		s,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (s *jsiiProxy_ServiceEntryV1Beta1) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		s,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type ServiceEntryV1Beta1Props struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting service registry.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
	Spec *ServiceEntryV1Beta1Spec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting service registry.
//
// See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
type ServiceEntryV1Beta1Spec struct {
	// The virtual IP addresses associated with the service.
	Addresses *[]*string `field:"optional" json:"addresses" yaml:"addresses"`
	// One or more endpoints associated with the service.
	Endpoints *[]*ServiceEntryV1Beta1SpecEndpoints `field:"optional" json:"endpoints" yaml:"endpoints"`
	// A list of namespaces to which this service is exported.
	ExportTo *[]*string `field:"optional" json:"exportTo" yaml:"exportTo"`
	// The hosts associated with the ServiceEntry.
	Hosts    *[]*string                      `field:"optional" json:"hosts" yaml:"hosts"`
	Location ServiceEntryV1Beta1SpecLocation `field:"optional" json:"location" yaml:"location"`
	// The ports associated with the external service.
	Ports *[]*ServiceEntryV1Beta1SpecPorts `field:"optional" json:"ports" yaml:"ports"`
	// Service discovery mode for the hosts.
	Resolution      ServiceEntryV1Beta1SpecResolution `field:"optional" json:"resolution" yaml:"resolution"`
	SubjectAltNames *[]*string                        `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
	// Applicable only for MESH_INTERNAL services.
	WorkloadSelector *ServiceEntryV1Beta1SpecWorkloadSelector `field:"optional" json:"workloadSelector" yaml:"workloadSelector"`
}

type ServiceEntryV1Beta1SpecEndpoints struct {
	Address *string `field:"optional" json:"address" yaml:"address"`
	// One or more labels associated with the endpoint.
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
	// The locality associated with the endpoint.
	Locality *string `field:"optional" json:"locality" yaml:"locality"`
	Network  *string `field:"optional" json:"network" yaml:"network"`
	// Set of ports associated with the endpoint.
	Ports          *map[string]*float64 `field:"optional" json:"ports" yaml:"ports"`
	ServiceAccount *string              `field:"optional" json:"serviceAccount" yaml:"serviceAccount"`
	// The load balancing weight associated with the endpoint.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}

type ServiceEntryV1Beta1SpecLocation string

const (
	// MESH_EXTERNAL.
	ServiceEntryV1Beta1SpecLocation_MESH_EXTERNAL ServiceEntryV1Beta1SpecLocation = "MESH_EXTERNAL"
	// MESH_INTERNAL.
	ServiceEntryV1Beta1SpecLocation_MESH_INTERNAL ServiceEntryV1Beta1SpecLocation = "MESH_INTERNAL"
)

type ServiceEntryV1Beta1SpecPorts struct {
	// Label assigned to the port.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A valid non-negative integer port number.
	Number *float64 `field:"optional" json:"number" yaml:"number"`
	// The protocol exposed on the port.
	Protocol   *string  `field:"optional" json:"protocol" yaml:"protocol"`
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

// Service discovery mode for the hosts.
type ServiceEntryV1Beta1SpecResolution string

const (
	// NONE.
	ServiceEntryV1Beta1SpecResolution_NONE ServiceEntryV1Beta1SpecResolution = "NONE"
	// STATIC.
	ServiceEntryV1Beta1SpecResolution_STATIC ServiceEntryV1Beta1SpecResolution = "STATIC"
	// DNS.
	ServiceEntryV1Beta1SpecResolution_DNS ServiceEntryV1Beta1SpecResolution = "DNS"
	// DNS_ROUND_ROBIN.
	ServiceEntryV1Beta1SpecResolution_DNS_ROUND_ROBIN ServiceEntryV1Beta1SpecResolution = "DNS_ROUND_ROBIN"
)

// Applicable only for MESH_INTERNAL services.
type ServiceEntryV1Beta1SpecWorkloadSelector struct {
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
}

type Sidecar interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for Sidecar
type jsiiProxy_Sidecar struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_Sidecar) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Sidecar) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Sidecar) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Sidecar) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Sidecar) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Sidecar) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_Sidecar) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "Sidecar" API object.
func NewSidecar(scope constructs.Construct, id *string, props *SidecarProps) Sidecar {
	_init_.Initialize()

	j := jsiiProxy_Sidecar{}

	_jsii_.Create(
		"networkingistioio.Sidecar",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "Sidecar" API object.
func NewSidecar_Override(s Sidecar, scope constructs.Construct, id *string, props *SidecarProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.Sidecar",
		[]interface{}{scope, id, props},
		s,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func Sidecar_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.Sidecar",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "Sidecar".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func Sidecar_Manifest(props *SidecarProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.Sidecar",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func Sidecar_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.Sidecar",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func Sidecar_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.Sidecar",
		"GVK",
		&returns,
	)
	return returns
}

func (s *jsiiProxy_Sidecar) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addDependency",
		args,
	)
}

func (s *jsiiProxy_Sidecar) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addJsonPatch",
		args,
	)
}

func (s *jsiiProxy_Sidecar) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		s,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (s *jsiiProxy_Sidecar) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		s,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type SidecarProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting network reachability of a sidecar.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
	Spec *SidecarSpec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting network reachability of a sidecar.
//
// See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
type SidecarSpec struct {
	Egress  *[]*SidecarSpecEgress  `field:"optional" json:"egress" yaml:"egress"`
	Ingress *[]*SidecarSpecIngress `field:"optional" json:"ingress" yaml:"ingress"`
	// Configuration for the outbound traffic policy.
	OutboundTrafficPolicy *SidecarSpecOutboundTrafficPolicy `field:"optional" json:"outboundTrafficPolicy" yaml:"outboundTrafficPolicy"`
	WorkloadSelector      *SidecarSpecWorkloadSelector      `field:"optional" json:"workloadSelector" yaml:"workloadSelector"`
}

type SidecarSpecEgress struct {
	Bind        *string                      `field:"optional" json:"bind" yaml:"bind"`
	CaptureMode SidecarSpecEgressCaptureMode `field:"optional" json:"captureMode" yaml:"captureMode"`
	Hosts       *[]*string                   `field:"optional" json:"hosts" yaml:"hosts"`
	// The port associated with the listener.
	Port *SidecarSpecEgressPort `field:"optional" json:"port" yaml:"port"`
}

type SidecarSpecEgressCaptureMode string

const (
	// DEFAULT.
	SidecarSpecEgressCaptureMode_DEFAULT SidecarSpecEgressCaptureMode = "DEFAULT"
	// IPTABLES.
	SidecarSpecEgressCaptureMode_IPTABLES SidecarSpecEgressCaptureMode = "IPTABLES"
	// NONE.
	SidecarSpecEgressCaptureMode_NONE SidecarSpecEgressCaptureMode = "NONE"
)

// The port associated with the listener.
type SidecarSpecEgressPort struct {
	// Label assigned to the port.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A valid non-negative integer port number.
	Number *float64 `field:"optional" json:"number" yaml:"number"`
	// The protocol exposed on the port.
	Protocol   *string  `field:"optional" json:"protocol" yaml:"protocol"`
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

type SidecarSpecIngress struct {
	// The IP to which the listener should be bound.
	Bind            *string                       `field:"optional" json:"bind" yaml:"bind"`
	CaptureMode     SidecarSpecIngressCaptureMode `field:"optional" json:"captureMode" yaml:"captureMode"`
	DefaultEndpoint *string                       `field:"optional" json:"defaultEndpoint" yaml:"defaultEndpoint"`
	// The port associated with the listener.
	Port *SidecarSpecIngressPort `field:"optional" json:"port" yaml:"port"`
	Tls  *SidecarSpecIngressTls  `field:"optional" json:"tls" yaml:"tls"`
}

type SidecarSpecIngressCaptureMode string

const (
	// DEFAULT.
	SidecarSpecIngressCaptureMode_DEFAULT SidecarSpecIngressCaptureMode = "DEFAULT"
	// IPTABLES.
	SidecarSpecIngressCaptureMode_IPTABLES SidecarSpecIngressCaptureMode = "IPTABLES"
	// NONE.
	SidecarSpecIngressCaptureMode_NONE SidecarSpecIngressCaptureMode = "NONE"
)

// The port associated with the listener.
type SidecarSpecIngressPort struct {
	// Label assigned to the port.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A valid non-negative integer port number.
	Number *float64 `field:"optional" json:"number" yaml:"number"`
	// The protocol exposed on the port.
	Protocol   *string  `field:"optional" json:"protocol" yaml:"protocol"`
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

type SidecarSpecIngressTls struct {
	// REQUIRED if mode is `MUTUAL`.
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// Optional: If specified, only support the specified cipher list.
	CipherSuites   *[]*string `field:"optional" json:"cipherSuites" yaml:"cipherSuites"`
	CredentialName *string    `field:"optional" json:"credentialName" yaml:"credentialName"`
	HttpsRedirect  *bool      `field:"optional" json:"httpsRedirect" yaml:"httpsRedirect"`
	// Optional: Maximum TLS protocol version.
	MaxProtocolVersion SidecarSpecIngressTlsMaxProtocolVersion `field:"optional" json:"maxProtocolVersion" yaml:"maxProtocolVersion"`
	// Optional: Minimum TLS protocol version.
	MinProtocolVersion SidecarSpecIngressTlsMinProtocolVersion `field:"optional" json:"minProtocolVersion" yaml:"minProtocolVersion"`
	Mode               SidecarSpecIngressTlsMode               `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
	ServerCertificate     *string    `field:"optional" json:"serverCertificate" yaml:"serverCertificate"`
	SubjectAltNames       *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
	VerifyCertificateHash *[]*string `field:"optional" json:"verifyCertificateHash" yaml:"verifyCertificateHash"`
	VerifyCertificateSpki *[]*string `field:"optional" json:"verifyCertificateSpki" yaml:"verifyCertificateSpki"`
}

// Optional: Maximum TLS protocol version.
type SidecarSpecIngressTlsMaxProtocolVersion string

const (
	// TLS_AUTO.
	SidecarSpecIngressTlsMaxProtocolVersion_TLS_AUTO SidecarSpecIngressTlsMaxProtocolVersion = "TLS_AUTO"
	// TLSV1_0.
	SidecarSpecIngressTlsMaxProtocolVersion_TLSV1_0 SidecarSpecIngressTlsMaxProtocolVersion = "TLSV1_0"
	// TLSV1_1.
	SidecarSpecIngressTlsMaxProtocolVersion_TLSV1_1 SidecarSpecIngressTlsMaxProtocolVersion = "TLSV1_1"
	// TLSV1_2.
	SidecarSpecIngressTlsMaxProtocolVersion_TLSV1_2 SidecarSpecIngressTlsMaxProtocolVersion = "TLSV1_2"
	// TLSV1_3.
	SidecarSpecIngressTlsMaxProtocolVersion_TLSV1_3 SidecarSpecIngressTlsMaxProtocolVersion = "TLSV1_3"
)

// Optional: Minimum TLS protocol version.
type SidecarSpecIngressTlsMinProtocolVersion string

const (
	// TLS_AUTO.
	SidecarSpecIngressTlsMinProtocolVersion_TLS_AUTO SidecarSpecIngressTlsMinProtocolVersion = "TLS_AUTO"
	// TLSV1_0.
	SidecarSpecIngressTlsMinProtocolVersion_TLSV1_0 SidecarSpecIngressTlsMinProtocolVersion = "TLSV1_0"
	// TLSV1_1.
	SidecarSpecIngressTlsMinProtocolVersion_TLSV1_1 SidecarSpecIngressTlsMinProtocolVersion = "TLSV1_1"
	// TLSV1_2.
	SidecarSpecIngressTlsMinProtocolVersion_TLSV1_2 SidecarSpecIngressTlsMinProtocolVersion = "TLSV1_2"
	// TLSV1_3.
	SidecarSpecIngressTlsMinProtocolVersion_TLSV1_3 SidecarSpecIngressTlsMinProtocolVersion = "TLSV1_3"
)

type SidecarSpecIngressTlsMode string

const (
	// PASSTHROUGH.
	SidecarSpecIngressTlsMode_PASSTHROUGH SidecarSpecIngressTlsMode = "PASSTHROUGH"
	// SIMPLE.
	SidecarSpecIngressTlsMode_SIMPLE SidecarSpecIngressTlsMode = "SIMPLE"
	// MUTUAL.
	SidecarSpecIngressTlsMode_MUTUAL SidecarSpecIngressTlsMode = "MUTUAL"
	// AUTO_PASSTHROUGH.
	SidecarSpecIngressTlsMode_AUTO_PASSTHROUGH SidecarSpecIngressTlsMode = "AUTO_PASSTHROUGH"
	// ISTIO_MUTUAL.
	SidecarSpecIngressTlsMode_ISTIO_MUTUAL SidecarSpecIngressTlsMode = "ISTIO_MUTUAL"
)

// Configuration for the outbound traffic policy.
type SidecarSpecOutboundTrafficPolicy struct {
	EgressProxy *SidecarSpecOutboundTrafficPolicyEgressProxy `field:"optional" json:"egressProxy" yaml:"egressProxy"`
	Mode        SidecarSpecOutboundTrafficPolicyMode         `field:"optional" json:"mode" yaml:"mode"`
}

type SidecarSpecOutboundTrafficPolicyEgressProxy struct {
	// The name of a service from the service registry.
	Host *string `field:"optional" json:"host" yaml:"host"`
	// Specifies the port on the host that is being addressed.
	Port *SidecarSpecOutboundTrafficPolicyEgressProxyPort `field:"optional" json:"port" yaml:"port"`
	// The name of a subset within the service.
	Subset *string `field:"optional" json:"subset" yaml:"subset"`
}

// Specifies the port on the host that is being addressed.
type SidecarSpecOutboundTrafficPolicyEgressProxyPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

type SidecarSpecOutboundTrafficPolicyMode string

const (
	// REGISTRY_ONLY.
	SidecarSpecOutboundTrafficPolicyMode_REGISTRY_ONLY SidecarSpecOutboundTrafficPolicyMode = "REGISTRY_ONLY"
	// ALLOW_ANY.
	SidecarSpecOutboundTrafficPolicyMode_ALLOW_ANY SidecarSpecOutboundTrafficPolicyMode = "ALLOW_ANY"
)

type SidecarSpecWorkloadSelector struct {
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
}

type SidecarV1Beta1 interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for SidecarV1Beta1
type jsiiProxy_SidecarV1Beta1 struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_SidecarV1Beta1) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SidecarV1Beta1) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SidecarV1Beta1) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SidecarV1Beta1) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SidecarV1Beta1) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SidecarV1Beta1) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SidecarV1Beta1) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "SidecarV1Beta1" API object.
func NewSidecarV1Beta1(scope constructs.Construct, id *string, props *SidecarV1Beta1Props) SidecarV1Beta1 {
	_init_.Initialize()

	j := jsiiProxy_SidecarV1Beta1{}

	_jsii_.Create(
		"networkingistioio.SidecarV1Beta1",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "SidecarV1Beta1" API object.
func NewSidecarV1Beta1_Override(s SidecarV1Beta1, scope constructs.Construct, id *string, props *SidecarV1Beta1Props) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.SidecarV1Beta1",
		[]interface{}{scope, id, props},
		s,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func SidecarV1Beta1_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.SidecarV1Beta1",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "SidecarV1Beta1".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func SidecarV1Beta1_Manifest(props *SidecarV1Beta1Props) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.SidecarV1Beta1",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func SidecarV1Beta1_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.SidecarV1Beta1",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func SidecarV1Beta1_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.SidecarV1Beta1",
		"GVK",
		&returns,
	)
	return returns
}

func (s *jsiiProxy_SidecarV1Beta1) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addDependency",
		args,
	)
}

func (s *jsiiProxy_SidecarV1Beta1) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addJsonPatch",
		args,
	)
}

func (s *jsiiProxy_SidecarV1Beta1) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		s,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (s *jsiiProxy_SidecarV1Beta1) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		s,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type SidecarV1Beta1Props struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting network reachability of a sidecar.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
	Spec *SidecarV1Beta1Spec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting network reachability of a sidecar.
//
// See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
type SidecarV1Beta1Spec struct {
	Egress  *[]*SidecarV1Beta1SpecEgress  `field:"optional" json:"egress" yaml:"egress"`
	Ingress *[]*SidecarV1Beta1SpecIngress `field:"optional" json:"ingress" yaml:"ingress"`
	// Configuration for the outbound traffic policy.
	OutboundTrafficPolicy *SidecarV1Beta1SpecOutboundTrafficPolicy `field:"optional" json:"outboundTrafficPolicy" yaml:"outboundTrafficPolicy"`
	WorkloadSelector      *SidecarV1Beta1SpecWorkloadSelector      `field:"optional" json:"workloadSelector" yaml:"workloadSelector"`
}

type SidecarV1Beta1SpecEgress struct {
	Bind        *string                             `field:"optional" json:"bind" yaml:"bind"`
	CaptureMode SidecarV1Beta1SpecEgressCaptureMode `field:"optional" json:"captureMode" yaml:"captureMode"`
	Hosts       *[]*string                          `field:"optional" json:"hosts" yaml:"hosts"`
	// The port associated with the listener.
	Port *SidecarV1Beta1SpecEgressPort `field:"optional" json:"port" yaml:"port"`
}

type SidecarV1Beta1SpecEgressCaptureMode string

const (
	// DEFAULT.
	SidecarV1Beta1SpecEgressCaptureMode_DEFAULT SidecarV1Beta1SpecEgressCaptureMode = "DEFAULT"
	// IPTABLES.
	SidecarV1Beta1SpecEgressCaptureMode_IPTABLES SidecarV1Beta1SpecEgressCaptureMode = "IPTABLES"
	// NONE.
	SidecarV1Beta1SpecEgressCaptureMode_NONE SidecarV1Beta1SpecEgressCaptureMode = "NONE"
)

// The port associated with the listener.
type SidecarV1Beta1SpecEgressPort struct {
	// Label assigned to the port.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A valid non-negative integer port number.
	Number *float64 `field:"optional" json:"number" yaml:"number"`
	// The protocol exposed on the port.
	Protocol   *string  `field:"optional" json:"protocol" yaml:"protocol"`
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

type SidecarV1Beta1SpecIngress struct {
	// The IP to which the listener should be bound.
	Bind            *string                              `field:"optional" json:"bind" yaml:"bind"`
	CaptureMode     SidecarV1Beta1SpecIngressCaptureMode `field:"optional" json:"captureMode" yaml:"captureMode"`
	DefaultEndpoint *string                              `field:"optional" json:"defaultEndpoint" yaml:"defaultEndpoint"`
	// The port associated with the listener.
	Port *SidecarV1Beta1SpecIngressPort `field:"optional" json:"port" yaml:"port"`
	Tls  *SidecarV1Beta1SpecIngressTls  `field:"optional" json:"tls" yaml:"tls"`
}

type SidecarV1Beta1SpecIngressCaptureMode string

const (
	// DEFAULT.
	SidecarV1Beta1SpecIngressCaptureMode_DEFAULT SidecarV1Beta1SpecIngressCaptureMode = "DEFAULT"
	// IPTABLES.
	SidecarV1Beta1SpecIngressCaptureMode_IPTABLES SidecarV1Beta1SpecIngressCaptureMode = "IPTABLES"
	// NONE.
	SidecarV1Beta1SpecIngressCaptureMode_NONE SidecarV1Beta1SpecIngressCaptureMode = "NONE"
)

// The port associated with the listener.
type SidecarV1Beta1SpecIngressPort struct {
	// Label assigned to the port.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A valid non-negative integer port number.
	Number *float64 `field:"optional" json:"number" yaml:"number"`
	// The protocol exposed on the port.
	Protocol   *string  `field:"optional" json:"protocol" yaml:"protocol"`
	TargetPort *float64 `field:"optional" json:"targetPort" yaml:"targetPort"`
}

type SidecarV1Beta1SpecIngressTls struct {
	// REQUIRED if mode is `MUTUAL`.
	CaCertificates *string `field:"optional" json:"caCertificates" yaml:"caCertificates"`
	// Optional: If specified, only support the specified cipher list.
	CipherSuites   *[]*string `field:"optional" json:"cipherSuites" yaml:"cipherSuites"`
	CredentialName *string    `field:"optional" json:"credentialName" yaml:"credentialName"`
	HttpsRedirect  *bool      `field:"optional" json:"httpsRedirect" yaml:"httpsRedirect"`
	// Optional: Maximum TLS protocol version.
	MaxProtocolVersion SidecarV1Beta1SpecIngressTlsMaxProtocolVersion `field:"optional" json:"maxProtocolVersion" yaml:"maxProtocolVersion"`
	// Optional: Minimum TLS protocol version.
	MinProtocolVersion SidecarV1Beta1SpecIngressTlsMinProtocolVersion `field:"optional" json:"minProtocolVersion" yaml:"minProtocolVersion"`
	Mode               SidecarV1Beta1SpecIngressTlsMode               `field:"optional" json:"mode" yaml:"mode"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
	PrivateKey *string `field:"optional" json:"privateKey" yaml:"privateKey"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
	ServerCertificate     *string    `field:"optional" json:"serverCertificate" yaml:"serverCertificate"`
	SubjectAltNames       *[]*string `field:"optional" json:"subjectAltNames" yaml:"subjectAltNames"`
	VerifyCertificateHash *[]*string `field:"optional" json:"verifyCertificateHash" yaml:"verifyCertificateHash"`
	VerifyCertificateSpki *[]*string `field:"optional" json:"verifyCertificateSpki" yaml:"verifyCertificateSpki"`
}

// Optional: Maximum TLS protocol version.
type SidecarV1Beta1SpecIngressTlsMaxProtocolVersion string

const (
	// TLS_AUTO.
	SidecarV1Beta1SpecIngressTlsMaxProtocolVersion_TLS_AUTO SidecarV1Beta1SpecIngressTlsMaxProtocolVersion = "TLS_AUTO"
	// TLSV1_0.
	SidecarV1Beta1SpecIngressTlsMaxProtocolVersion_TLSV1_0 SidecarV1Beta1SpecIngressTlsMaxProtocolVersion = "TLSV1_0"
	// TLSV1_1.
	SidecarV1Beta1SpecIngressTlsMaxProtocolVersion_TLSV1_1 SidecarV1Beta1SpecIngressTlsMaxProtocolVersion = "TLSV1_1"
	// TLSV1_2.
	SidecarV1Beta1SpecIngressTlsMaxProtocolVersion_TLSV1_2 SidecarV1Beta1SpecIngressTlsMaxProtocolVersion = "TLSV1_2"
	// TLSV1_3.
	SidecarV1Beta1SpecIngressTlsMaxProtocolVersion_TLSV1_3 SidecarV1Beta1SpecIngressTlsMaxProtocolVersion = "TLSV1_3"
)

// Optional: Minimum TLS protocol version.
type SidecarV1Beta1SpecIngressTlsMinProtocolVersion string

const (
	// TLS_AUTO.
	SidecarV1Beta1SpecIngressTlsMinProtocolVersion_TLS_AUTO SidecarV1Beta1SpecIngressTlsMinProtocolVersion = "TLS_AUTO"
	// TLSV1_0.
	SidecarV1Beta1SpecIngressTlsMinProtocolVersion_TLSV1_0 SidecarV1Beta1SpecIngressTlsMinProtocolVersion = "TLSV1_0"
	// TLSV1_1.
	SidecarV1Beta1SpecIngressTlsMinProtocolVersion_TLSV1_1 SidecarV1Beta1SpecIngressTlsMinProtocolVersion = "TLSV1_1"
	// TLSV1_2.
	SidecarV1Beta1SpecIngressTlsMinProtocolVersion_TLSV1_2 SidecarV1Beta1SpecIngressTlsMinProtocolVersion = "TLSV1_2"
	// TLSV1_3.
	SidecarV1Beta1SpecIngressTlsMinProtocolVersion_TLSV1_3 SidecarV1Beta1SpecIngressTlsMinProtocolVersion = "TLSV1_3"
)

type SidecarV1Beta1SpecIngressTlsMode string

const (
	// PASSTHROUGH.
	SidecarV1Beta1SpecIngressTlsMode_PASSTHROUGH SidecarV1Beta1SpecIngressTlsMode = "PASSTHROUGH"
	// SIMPLE.
	SidecarV1Beta1SpecIngressTlsMode_SIMPLE SidecarV1Beta1SpecIngressTlsMode = "SIMPLE"
	// MUTUAL.
	SidecarV1Beta1SpecIngressTlsMode_MUTUAL SidecarV1Beta1SpecIngressTlsMode = "MUTUAL"
	// AUTO_PASSTHROUGH.
	SidecarV1Beta1SpecIngressTlsMode_AUTO_PASSTHROUGH SidecarV1Beta1SpecIngressTlsMode = "AUTO_PASSTHROUGH"
	// ISTIO_MUTUAL.
	SidecarV1Beta1SpecIngressTlsMode_ISTIO_MUTUAL SidecarV1Beta1SpecIngressTlsMode = "ISTIO_MUTUAL"
)

// Configuration for the outbound traffic policy.
type SidecarV1Beta1SpecOutboundTrafficPolicy struct {
	EgressProxy *SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy `field:"optional" json:"egressProxy" yaml:"egressProxy"`
	Mode        SidecarV1Beta1SpecOutboundTrafficPolicyMode         `field:"optional" json:"mode" yaml:"mode"`
}

type SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy struct {
	// The name of a service from the service registry.
	Host *string `field:"optional" json:"host" yaml:"host"`
	// Specifies the port on the host that is being addressed.
	Port *SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort `field:"optional" json:"port" yaml:"port"`
	// The name of a subset within the service.
	Subset *string `field:"optional" json:"subset" yaml:"subset"`
}

// Specifies the port on the host that is being addressed.
type SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

type SidecarV1Beta1SpecOutboundTrafficPolicyMode string

const (
	// REGISTRY_ONLY.
	SidecarV1Beta1SpecOutboundTrafficPolicyMode_REGISTRY_ONLY SidecarV1Beta1SpecOutboundTrafficPolicyMode = "REGISTRY_ONLY"
	// ALLOW_ANY.
	SidecarV1Beta1SpecOutboundTrafficPolicyMode_ALLOW_ANY SidecarV1Beta1SpecOutboundTrafficPolicyMode = "ALLOW_ANY"
)

type SidecarV1Beta1SpecWorkloadSelector struct {
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
}

type VirtualService interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for VirtualService
type jsiiProxy_VirtualService struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_VirtualService) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_VirtualService) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_VirtualService) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_VirtualService) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_VirtualService) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_VirtualService) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_VirtualService) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "VirtualService" API object.
func NewVirtualService(scope constructs.Construct, id *string, props *VirtualServiceProps) VirtualService {
	_init_.Initialize()

	j := jsiiProxy_VirtualService{}

	_jsii_.Create(
		"networkingistioio.VirtualService",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "VirtualService" API object.
func NewVirtualService_Override(v VirtualService, scope constructs.Construct, id *string, props *VirtualServiceProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.VirtualService",
		[]interface{}{scope, id, props},
		v,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func VirtualService_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.VirtualService",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "VirtualService".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func VirtualService_Manifest(props *VirtualServiceProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.VirtualService",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func VirtualService_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.VirtualService",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func VirtualService_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.VirtualService",
		"GVK",
		&returns,
	)
	return returns
}

func (v *jsiiProxy_VirtualService) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		v,
		"addDependency",
		args,
	)
}

func (v *jsiiProxy_VirtualService) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		v,
		"addJsonPatch",
		args,
	)
}

func (v *jsiiProxy_VirtualService) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		v,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (v *jsiiProxy_VirtualService) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		v,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type VirtualServiceProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting label/content routing, sni routing, etc.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
	Spec *VirtualServiceSpec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting label/content routing, sni routing, etc.
//
// See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
type VirtualServiceSpec struct {
	// A list of namespaces to which this virtual service is exported.
	ExportTo *[]*string `field:"optional" json:"exportTo" yaml:"exportTo"`
	// The names of gateways and sidecars that should apply these routes.
	Gateways *[]*string `field:"optional" json:"gateways" yaml:"gateways"`
	// The destination hosts to which traffic is being sent.
	Hosts *[]*string `field:"optional" json:"hosts" yaml:"hosts"`
	// An ordered list of route rules for HTTP traffic.
	Http *[]*VirtualServiceSpecHttp `field:"optional" json:"http" yaml:"http"`
	// An ordered list of route rules for opaque TCP traffic.
	Tcp *[]*VirtualServiceSpecTcp `field:"optional" json:"tcp" yaml:"tcp"`
	Tls *[]*VirtualServiceSpecTls `field:"optional" json:"tls" yaml:"tls"`
}

type VirtualServiceSpecHttp struct {
	// Cross-Origin Resource Sharing policy (CORS).
	CorsPolicy *VirtualServiceSpecHttpCorsPolicy `field:"optional" json:"corsPolicy" yaml:"corsPolicy"`
	Delegate   *VirtualServiceSpecHttpDelegate   `field:"optional" json:"delegate" yaml:"delegate"`
	// A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
	DirectResponse *VirtualServiceSpecHttpDirectResponse `field:"optional" json:"directResponse" yaml:"directResponse"`
	// Fault injection policy to apply on HTTP traffic at the client side.
	Fault   *VirtualServiceSpecHttpFault    `field:"optional" json:"fault" yaml:"fault"`
	Headers *VirtualServiceSpecHttpHeaders  `field:"optional" json:"headers" yaml:"headers"`
	Match   *[]*VirtualServiceSpecHttpMatch `field:"optional" json:"match" yaml:"match"`
	Mirror  *VirtualServiceSpecHttpMirror   `field:"optional" json:"mirror" yaml:"mirror"`
	// Percentage of the traffic to be mirrored by the `mirror` field.
	MirrorPercent *float64 `field:"optional" json:"mirrorPercent" yaml:"mirrorPercent"`
	// Percentage of the traffic to be mirrored by the `mirror` field.
	MirrorPercentage *VirtualServiceSpecHttpMirrorPercentage `field:"optional" json:"mirrorPercentage" yaml:"mirrorPercentage"`
	// The name assigned to the route for debugging purposes.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
	Redirect *VirtualServiceSpecHttpRedirect `field:"optional" json:"redirect" yaml:"redirect"`
	// Retry policy for HTTP requests.
	Retries *VirtualServiceSpecHttpRetries `field:"optional" json:"retries" yaml:"retries"`
	// Rewrite HTTP URIs and Authority headers.
	Rewrite *VirtualServiceSpecHttpRewrite `field:"optional" json:"rewrite" yaml:"rewrite"`
	// A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
	Route *[]*VirtualServiceSpecHttpRoute `field:"optional" json:"route" yaml:"route"`
	// Timeout for HTTP requests, default is disabled.
	Timeout *string `field:"optional" json:"timeout" yaml:"timeout"`
}

// Cross-Origin Resource Sharing policy (CORS).
type VirtualServiceSpecHttpCorsPolicy struct {
	AllowCredentials *bool      `field:"optional" json:"allowCredentials" yaml:"allowCredentials"`
	AllowHeaders     *[]*string `field:"optional" json:"allowHeaders" yaml:"allowHeaders"`
	// List of HTTP methods allowed to access the resource.
	AllowMethods *[]*string `field:"optional" json:"allowMethods" yaml:"allowMethods"`
	// The list of origins that are allowed to perform CORS requests.
	AllowOrigin *[]*string `field:"optional" json:"allowOrigin" yaml:"allowOrigin"`
	// String patterns that match allowed origins.
	AllowOrigins  *[]*VirtualServiceSpecHttpCorsPolicyAllowOrigins `field:"optional" json:"allowOrigins" yaml:"allowOrigins"`
	ExposeHeaders *[]*string                                       `field:"optional" json:"exposeHeaders" yaml:"exposeHeaders"`
	MaxAge        *string                                          `field:"optional" json:"maxAge" yaml:"maxAge"`
}

type VirtualServiceSpecHttpCorsPolicyAllowOrigins struct {
	Exact  *string `field:"optional" json:"exact" yaml:"exact"`
	Prefix *string `field:"optional" json:"prefix" yaml:"prefix"`
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex *string `field:"optional" json:"regex" yaml:"regex"`
}

type VirtualServiceSpecHttpDelegate struct {
	// Name specifies the name of the delegate VirtualService.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Namespace specifies the namespace where the delegate VirtualService resides.
	Namespace *string `field:"optional" json:"namespace" yaml:"namespace"`
}

// A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
type VirtualServiceSpecHttpDirectResponse struct {
	// Specifies the content of the response body.
	Body *VirtualServiceSpecHttpDirectResponseBody `field:"optional" json:"body" yaml:"body"`
	// Specifies the HTTP response status to be returned.
	Status *float64 `field:"optional" json:"status" yaml:"status"`
}

// Specifies the content of the response body.
type VirtualServiceSpecHttpDirectResponseBody struct {
	// response body as base64 encoded bytes.
	Bytes  *string `field:"optional" json:"bytes" yaml:"bytes"`
	String *string `field:"optional" json:"string" yaml:"string"`
}

// Fault injection policy to apply on HTTP traffic at the client side.
type VirtualServiceSpecHttpFault struct {
	Abort *VirtualServiceSpecHttpFaultAbort `field:"optional" json:"abort" yaml:"abort"`
	Delay *VirtualServiceSpecHttpFaultDelay `field:"optional" json:"delay" yaml:"delay"`
}

type VirtualServiceSpecHttpFaultAbort struct {
	// GRPC status code to use to abort the request.
	GrpcStatus *string `field:"optional" json:"grpcStatus" yaml:"grpcStatus"`
	Http2Error *string `field:"optional" json:"http2Error" yaml:"http2Error"`
	// HTTP status code to use to abort the Http request.
	HttpStatus *float64 `field:"optional" json:"httpStatus" yaml:"httpStatus"`
	// Percentage of requests to be aborted with the error code provided.
	Percentage *VirtualServiceSpecHttpFaultAbortPercentage `field:"optional" json:"percentage" yaml:"percentage"`
}

// Percentage of requests to be aborted with the error code provided.
type VirtualServiceSpecHttpFaultAbortPercentage struct {
	Value *float64 `field:"optional" json:"value" yaml:"value"`
}

type VirtualServiceSpecHttpFaultDelay struct {
	ExponentialDelay *string `field:"optional" json:"exponentialDelay" yaml:"exponentialDelay"`
	// Add a fixed delay before forwarding the request.
	FixedDelay *string `field:"optional" json:"fixedDelay" yaml:"fixedDelay"`
	// Percentage of requests on which the delay will be injected (0-100).
	Percent *float64 `field:"optional" json:"percent" yaml:"percent"`
	// Percentage of requests on which the delay will be injected.
	Percentage *VirtualServiceSpecHttpFaultDelayPercentage `field:"optional" json:"percentage" yaml:"percentage"`
}

// Percentage of requests on which the delay will be injected.
type VirtualServiceSpecHttpFaultDelayPercentage struct {
	Value *float64 `field:"optional" json:"value" yaml:"value"`
}

type VirtualServiceSpecHttpHeaders struct {
	Request  *VirtualServiceSpecHttpHeadersRequest  `field:"optional" json:"request" yaml:"request"`
	Response *VirtualServiceSpecHttpHeadersResponse `field:"optional" json:"response" yaml:"response"`
}

type VirtualServiceSpecHttpHeadersRequest struct {
	Add    *map[string]*string `field:"optional" json:"add" yaml:"add"`
	Remove *[]*string          `field:"optional" json:"remove" yaml:"remove"`
	Set    *map[string]*string `field:"optional" json:"set" yaml:"set"`
}

type VirtualServiceSpecHttpHeadersResponse struct {
	Add    *map[string]*string `field:"optional" json:"add" yaml:"add"`
	Remove *[]*string          `field:"optional" json:"remove" yaml:"remove"`
	Set    *map[string]*string `field:"optional" json:"set" yaml:"set"`
}

type VirtualServiceSpecHttpMatch struct {
	Authority *VirtualServiceSpecHttpMatchAuthority `field:"optional" json:"authority" yaml:"authority"`
	// Names of gateways where the rule should be applied.
	Gateways *[]*string                                      `field:"optional" json:"gateways" yaml:"gateways"`
	Headers  *map[string]*VirtualServiceSpecHttpMatchHeaders `field:"optional" json:"headers" yaml:"headers"`
	// Flag to specify whether the URI matching should be case-insensitive.
	IgnoreUriCase *bool                              `field:"optional" json:"ignoreUriCase" yaml:"ignoreUriCase"`
	Method        *VirtualServiceSpecHttpMatchMethod `field:"optional" json:"method" yaml:"method"`
	// The name assigned to a match.
	Name *string `field:"optional" json:"name" yaml:"name"`
	// Specifies the ports on the host that is being addressed.
	Port *float64 `field:"optional" json:"port" yaml:"port"`
	// Query parameters for matching.
	QueryParams  *map[string]*VirtualServiceSpecHttpMatchQueryParams `field:"optional" json:"queryParams" yaml:"queryParams"`
	Scheme       *VirtualServiceSpecHttpMatchScheme                  `field:"optional" json:"scheme" yaml:"scheme"`
	SourceLabels *map[string]*string                                 `field:"optional" json:"sourceLabels" yaml:"sourceLabels"`
	// Source namespace constraining the applicability of a rule to workloads in that namespace.
	SourceNamespace *string `field:"optional" json:"sourceNamespace" yaml:"sourceNamespace"`
	// The human readable prefix to use when emitting statistics for this route.
	StatPrefix *string                         `field:"optional" json:"statPrefix" yaml:"statPrefix"`
	Uri        *VirtualServiceSpecHttpMatchUri `field:"optional" json:"uri" yaml:"uri"`
	// withoutHeader has the same syntax with the header, but has opposite meaning.
	WithoutHeaders *map[string]*VirtualServiceSpecHttpMatchWithoutHeaders `field:"optional" json:"withoutHeaders" yaml:"withoutHeaders"`
}

type VirtualServiceSpecHttpMatchAuthority struct {
	Exact  *string `field:"optional" json:"exact" yaml:"exact"`
	Prefix *string `field:"optional" json:"prefix" yaml:"prefix"`
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex *string `field:"optional" json:"regex" yaml:"regex"`
}

type VirtualServiceSpecHttpMatchHeaders struct {
	Exact  *string `field:"optional" json:"exact" yaml:"exact"`
	Prefix *string `field:"optional" json:"prefix" yaml:"prefix"`
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex *string `field:"optional" json:"regex" yaml:"regex"`
}

type VirtualServiceSpecHttpMatchMethod struct {
	Exact  *string `field:"optional" json:"exact" yaml:"exact"`
	Prefix *string `field:"optional" json:"prefix" yaml:"prefix"`
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex *string `field:"optional" json:"regex" yaml:"regex"`
}

type VirtualServiceSpecHttpMatchQueryParams struct {
	Exact  *string `field:"optional" json:"exact" yaml:"exact"`
	Prefix *string `field:"optional" json:"prefix" yaml:"prefix"`
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex *string `field:"optional" json:"regex" yaml:"regex"`
}

type VirtualServiceSpecHttpMatchScheme struct {
	Exact  *string `field:"optional" json:"exact" yaml:"exact"`
	Prefix *string `field:"optional" json:"prefix" yaml:"prefix"`
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex *string `field:"optional" json:"regex" yaml:"regex"`
}

type VirtualServiceSpecHttpMatchUri struct {
	Exact  *string `field:"optional" json:"exact" yaml:"exact"`
	Prefix *string `field:"optional" json:"prefix" yaml:"prefix"`
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex *string `field:"optional" json:"regex" yaml:"regex"`
}

type VirtualServiceSpecHttpMatchWithoutHeaders struct {
	Exact  *string `field:"optional" json:"exact" yaml:"exact"`
	Prefix *string `field:"optional" json:"prefix" yaml:"prefix"`
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex *string `field:"optional" json:"regex" yaml:"regex"`
}

type VirtualServiceSpecHttpMirror struct {
	// The name of a service from the service registry.
	Host *string `field:"optional" json:"host" yaml:"host"`
	// Specifies the port on the host that is being addressed.
	Port *VirtualServiceSpecHttpMirrorPort `field:"optional" json:"port" yaml:"port"`
	// The name of a subset within the service.
	Subset *string `field:"optional" json:"subset" yaml:"subset"`
}

// Percentage of the traffic to be mirrored by the `mirror` field.
type VirtualServiceSpecHttpMirrorPercentage struct {
	Value *float64 `field:"optional" json:"value" yaml:"value"`
}

// Specifies the port on the host that is being addressed.
type VirtualServiceSpecHttpMirrorPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

// A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
type VirtualServiceSpecHttpRedirect struct {
	Authority  *string                                  `field:"optional" json:"authority" yaml:"authority"`
	DerivePort VirtualServiceSpecHttpRedirectDerivePort `field:"optional" json:"derivePort" yaml:"derivePort"`
	// On a redirect, overwrite the port portion of the URL with this value.
	Port         *float64 `field:"optional" json:"port" yaml:"port"`
	RedirectCode *float64 `field:"optional" json:"redirectCode" yaml:"redirectCode"`
	// On a redirect, overwrite the scheme portion of the URL with this value.
	Scheme *string `field:"optional" json:"scheme" yaml:"scheme"`
	Uri    *string `field:"optional" json:"uri" yaml:"uri"`
}

type VirtualServiceSpecHttpRedirectDerivePort string

const (
	// FROM_PROTOCOL_DEFAULT.
	VirtualServiceSpecHttpRedirectDerivePort_FROM_PROTOCOL_DEFAULT VirtualServiceSpecHttpRedirectDerivePort = "FROM_PROTOCOL_DEFAULT"
	// FROM_REQUEST_PORT.
	VirtualServiceSpecHttpRedirectDerivePort_FROM_REQUEST_PORT VirtualServiceSpecHttpRedirectDerivePort = "FROM_REQUEST_PORT"
)

// Retry policy for HTTP requests.
type VirtualServiceSpecHttpRetries struct {
	// Number of retries to be allowed for a given request.
	Attempts *float64 `field:"optional" json:"attempts" yaml:"attempts"`
	// Timeout per attempt for a given request, including the initial call and any retries.
	PerTryTimeout *string `field:"optional" json:"perTryTimeout" yaml:"perTryTimeout"`
	// Specifies the conditions under which retry takes place.
	RetryOn *string `field:"optional" json:"retryOn" yaml:"retryOn"`
	// Flag to specify whether the retries should retry to other localities.
	RetryRemoteLocalities *bool `field:"optional" json:"retryRemoteLocalities" yaml:"retryRemoteLocalities"`
}

// Rewrite HTTP URIs and Authority headers.
type VirtualServiceSpecHttpRewrite struct {
	// rewrite the Authority/Host header with this value.
	Authority *string `field:"optional" json:"authority" yaml:"authority"`
	Uri       *string `field:"optional" json:"uri" yaml:"uri"`
}

type VirtualServiceSpecHttpRoute struct {
	Destination *VirtualServiceSpecHttpRouteDestination `field:"optional" json:"destination" yaml:"destination"`
	Headers     *VirtualServiceSpecHttpRouteHeaders     `field:"optional" json:"headers" yaml:"headers"`
	// Weight specifies the relative proportion of traffic to be forwarded to the destination.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}

type VirtualServiceSpecHttpRouteDestination struct {
	// The name of a service from the service registry.
	Host *string `field:"optional" json:"host" yaml:"host"`
	// Specifies the port on the host that is being addressed.
	Port *VirtualServiceSpecHttpRouteDestinationPort `field:"optional" json:"port" yaml:"port"`
	// The name of a subset within the service.
	Subset *string `field:"optional" json:"subset" yaml:"subset"`
}

// Specifies the port on the host that is being addressed.
type VirtualServiceSpecHttpRouteDestinationPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

type VirtualServiceSpecHttpRouteHeaders struct {
	Request  *VirtualServiceSpecHttpRouteHeadersRequest  `field:"optional" json:"request" yaml:"request"`
	Response *VirtualServiceSpecHttpRouteHeadersResponse `field:"optional" json:"response" yaml:"response"`
}

type VirtualServiceSpecHttpRouteHeadersRequest struct {
	Add    *map[string]*string `field:"optional" json:"add" yaml:"add"`
	Remove *[]*string          `field:"optional" json:"remove" yaml:"remove"`
	Set    *map[string]*string `field:"optional" json:"set" yaml:"set"`
}

type VirtualServiceSpecHttpRouteHeadersResponse struct {
	Add    *map[string]*string `field:"optional" json:"add" yaml:"add"`
	Remove *[]*string          `field:"optional" json:"remove" yaml:"remove"`
	Set    *map[string]*string `field:"optional" json:"set" yaml:"set"`
}

type VirtualServiceSpecTcp struct {
	Match *[]*VirtualServiceSpecTcpMatch `field:"optional" json:"match" yaml:"match"`
	// The destination to which the connection should be forwarded to.
	Route *[]*VirtualServiceSpecTcpRoute `field:"optional" json:"route" yaml:"route"`
}

type VirtualServiceSpecTcpMatch struct {
	// IPv4 or IPv6 ip addresses of destination with optional subnet.
	DestinationSubnets *[]*string `field:"optional" json:"destinationSubnets" yaml:"destinationSubnets"`
	// Names of gateways where the rule should be applied.
	Gateways *[]*string `field:"optional" json:"gateways" yaml:"gateways"`
	// Specifies the port on the host that is being addressed.
	Port         *float64            `field:"optional" json:"port" yaml:"port"`
	SourceLabels *map[string]*string `field:"optional" json:"sourceLabels" yaml:"sourceLabels"`
	// Source namespace constraining the applicability of a rule to workloads in that namespace.
	SourceNamespace *string `field:"optional" json:"sourceNamespace" yaml:"sourceNamespace"`
	// IPv4 or IPv6 ip address of source with optional subnet.
	SourceSubnet *string `field:"optional" json:"sourceSubnet" yaml:"sourceSubnet"`
}

type VirtualServiceSpecTcpRoute struct {
	Destination *VirtualServiceSpecTcpRouteDestination `field:"optional" json:"destination" yaml:"destination"`
	// Weight specifies the relative proportion of traffic to be forwarded to the destination.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}

type VirtualServiceSpecTcpRouteDestination struct {
	// The name of a service from the service registry.
	Host *string `field:"optional" json:"host" yaml:"host"`
	// Specifies the port on the host that is being addressed.
	Port *VirtualServiceSpecTcpRouteDestinationPort `field:"optional" json:"port" yaml:"port"`
	// The name of a subset within the service.
	Subset *string `field:"optional" json:"subset" yaml:"subset"`
}

// Specifies the port on the host that is being addressed.
type VirtualServiceSpecTcpRouteDestinationPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

type VirtualServiceSpecTls struct {
	Match *[]*VirtualServiceSpecTlsMatch `field:"optional" json:"match" yaml:"match"`
	// The destination to which the connection should be forwarded to.
	Route *[]*VirtualServiceSpecTlsRoute `field:"optional" json:"route" yaml:"route"`
}

type VirtualServiceSpecTlsMatch struct {
	// IPv4 or IPv6 ip addresses of destination with optional subnet.
	DestinationSubnets *[]*string `field:"optional" json:"destinationSubnets" yaml:"destinationSubnets"`
	// Names of gateways where the rule should be applied.
	Gateways *[]*string `field:"optional" json:"gateways" yaml:"gateways"`
	// Specifies the port on the host that is being addressed.
	Port *float64 `field:"optional" json:"port" yaml:"port"`
	// SNI (server name indicator) to match on.
	SniHosts     *[]*string          `field:"optional" json:"sniHosts" yaml:"sniHosts"`
	SourceLabels *map[string]*string `field:"optional" json:"sourceLabels" yaml:"sourceLabels"`
	// Source namespace constraining the applicability of a rule to workloads in that namespace.
	SourceNamespace *string `field:"optional" json:"sourceNamespace" yaml:"sourceNamespace"`
}

type VirtualServiceSpecTlsRoute struct {
	Destination *VirtualServiceSpecTlsRouteDestination `field:"optional" json:"destination" yaml:"destination"`
	// Weight specifies the relative proportion of traffic to be forwarded to the destination.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}

type VirtualServiceSpecTlsRouteDestination struct {
	// The name of a service from the service registry.
	Host *string `field:"optional" json:"host" yaml:"host"`
	// Specifies the port on the host that is being addressed.
	Port *VirtualServiceSpecTlsRouteDestinationPort `field:"optional" json:"port" yaml:"port"`
	// The name of a subset within the service.
	Subset *string `field:"optional" json:"subset" yaml:"subset"`
}

// Specifies the port on the host that is being addressed.
type VirtualServiceSpecTlsRouteDestinationPort struct {
	Number *float64 `field:"optional" json:"number" yaml:"number"`
}

type WorkloadEntry interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for WorkloadEntry
type jsiiProxy_WorkloadEntry struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_WorkloadEntry) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntry) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntry) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntry) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntry) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntry) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntry) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "WorkloadEntry" API object.
func NewWorkloadEntry(scope constructs.Construct, id *string, props *WorkloadEntryProps) WorkloadEntry {
	_init_.Initialize()

	j := jsiiProxy_WorkloadEntry{}

	_jsii_.Create(
		"networkingistioio.WorkloadEntry",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "WorkloadEntry" API object.
func NewWorkloadEntry_Override(w WorkloadEntry, scope constructs.Construct, id *string, props *WorkloadEntryProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.WorkloadEntry",
		[]interface{}{scope, id, props},
		w,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func WorkloadEntry_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadEntry",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "WorkloadEntry".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func WorkloadEntry_Manifest(props *WorkloadEntryProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadEntry",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func WorkloadEntry_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadEntry",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func WorkloadEntry_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.WorkloadEntry",
		"GVK",
		&returns,
	)
	return returns
}

func (w *jsiiProxy_WorkloadEntry) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		w,
		"addDependency",
		args,
	)
}

func (w *jsiiProxy_WorkloadEntry) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		w,
		"addJsonPatch",
		args,
	)
}

func (w *jsiiProxy_WorkloadEntry) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		w,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (w *jsiiProxy_WorkloadEntry) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		w,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type WorkloadEntryProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting VMs onboarded into the mesh.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
	Spec *WorkloadEntrySpec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting VMs onboarded into the mesh.
//
// See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
type WorkloadEntrySpec struct {
	Address *string `field:"optional" json:"address" yaml:"address"`
	// One or more labels associated with the endpoint.
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
	// The locality associated with the endpoint.
	Locality *string `field:"optional" json:"locality" yaml:"locality"`
	Network  *string `field:"optional" json:"network" yaml:"network"`
	// Set of ports associated with the endpoint.
	Ports          *map[string]*float64 `field:"optional" json:"ports" yaml:"ports"`
	ServiceAccount *string              `field:"optional" json:"serviceAccount" yaml:"serviceAccount"`
	// The load balancing weight associated with the endpoint.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}

type WorkloadEntryV1Beta1 interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for WorkloadEntryV1Beta1
type jsiiProxy_WorkloadEntryV1Beta1 struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_WorkloadEntryV1Beta1) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntryV1Beta1) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntryV1Beta1) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntryV1Beta1) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntryV1Beta1) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntryV1Beta1) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadEntryV1Beta1) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "WorkloadEntryV1Beta1" API object.
func NewWorkloadEntryV1Beta1(scope constructs.Construct, id *string, props *WorkloadEntryV1Beta1Props) WorkloadEntryV1Beta1 {
	_init_.Initialize()

	j := jsiiProxy_WorkloadEntryV1Beta1{}

	_jsii_.Create(
		"networkingistioio.WorkloadEntryV1Beta1",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "WorkloadEntryV1Beta1" API object.
func NewWorkloadEntryV1Beta1_Override(w WorkloadEntryV1Beta1, scope constructs.Construct, id *string, props *WorkloadEntryV1Beta1Props) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.WorkloadEntryV1Beta1",
		[]interface{}{scope, id, props},
		w,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func WorkloadEntryV1Beta1_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadEntryV1Beta1",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "WorkloadEntryV1Beta1".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func WorkloadEntryV1Beta1_Manifest(props *WorkloadEntryV1Beta1Props) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadEntryV1Beta1",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func WorkloadEntryV1Beta1_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadEntryV1Beta1",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func WorkloadEntryV1Beta1_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.WorkloadEntryV1Beta1",
		"GVK",
		&returns,
	)
	return returns
}

func (w *jsiiProxy_WorkloadEntryV1Beta1) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		w,
		"addDependency",
		args,
	)
}

func (w *jsiiProxy_WorkloadEntryV1Beta1) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		w,
		"addJsonPatch",
		args,
	)
}

func (w *jsiiProxy_WorkloadEntryV1Beta1) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		w,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (w *jsiiProxy_WorkloadEntryV1Beta1) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		w,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type WorkloadEntryV1Beta1Props struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Configuration affecting VMs onboarded into the mesh.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
	Spec *WorkloadEntryV1Beta1Spec `field:"optional" json:"spec" yaml:"spec"`
}

// Configuration affecting VMs onboarded into the mesh.
//
// See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
type WorkloadEntryV1Beta1Spec struct {
	Address *string `field:"optional" json:"address" yaml:"address"`
	// One or more labels associated with the endpoint.
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
	// The locality associated with the endpoint.
	Locality *string `field:"optional" json:"locality" yaml:"locality"`
	Network  *string `field:"optional" json:"network" yaml:"network"`
	// Set of ports associated with the endpoint.
	Ports          *map[string]*float64 `field:"optional" json:"ports" yaml:"ports"`
	ServiceAccount *string              `field:"optional" json:"serviceAccount" yaml:"serviceAccount"`
	// The load balancing weight associated with the endpoint.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}

type WorkloadGroup interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for WorkloadGroup
type jsiiProxy_WorkloadGroup struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_WorkloadGroup) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroup) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroup) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroup) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroup) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroup) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroup) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "WorkloadGroup" API object.
func NewWorkloadGroup(scope constructs.Construct, id *string, props *WorkloadGroupProps) WorkloadGroup {
	_init_.Initialize()

	j := jsiiProxy_WorkloadGroup{}

	_jsii_.Create(
		"networkingistioio.WorkloadGroup",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "WorkloadGroup" API object.
func NewWorkloadGroup_Override(w WorkloadGroup, scope constructs.Construct, id *string, props *WorkloadGroupProps) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.WorkloadGroup",
		[]interface{}{scope, id, props},
		w,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func WorkloadGroup_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadGroup",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "WorkloadGroup".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func WorkloadGroup_Manifest(props *WorkloadGroupProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadGroup",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func WorkloadGroup_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadGroup",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func WorkloadGroup_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.WorkloadGroup",
		"GVK",
		&returns,
	)
	return returns
}

func (w *jsiiProxy_WorkloadGroup) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		w,
		"addDependency",
		args,
	)
}

func (w *jsiiProxy_WorkloadGroup) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		w,
		"addJsonPatch",
		args,
	)
}

func (w *jsiiProxy_WorkloadGroup) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		w,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (w *jsiiProxy_WorkloadGroup) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		w,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type WorkloadGroupProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// Describes a collection of workload instances.
	//
	// See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
	Spec *WorkloadGroupSpec `field:"optional" json:"spec" yaml:"spec"`
}

// Describes a collection of workload instances.
//
// See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
type WorkloadGroupSpec struct {
	// Metadata that will be used for all corresponding `WorkloadEntries`.
	Metadata *WorkloadGroupSpecMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
	Probe *WorkloadGroupSpecProbe `field:"optional" json:"probe" yaml:"probe"`
	// Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
	Template *WorkloadGroupSpecTemplate `field:"optional" json:"template" yaml:"template"`
}

// Metadata that will be used for all corresponding `WorkloadEntries`.
type WorkloadGroupSpecMetadata struct {
	Annotations *map[string]*string `field:"optional" json:"annotations" yaml:"annotations"`
	Labels      *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
}

// `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
type WorkloadGroupSpecProbe struct {
	// Health is determined by how the command that is executed exited.
	Exec *WorkloadGroupSpecProbeExec `field:"optional" json:"exec" yaml:"exec"`
	// Minimum consecutive failures for the probe to be considered failed after having succeeded.
	FailureThreshold *float64                       `field:"optional" json:"failureThreshold" yaml:"failureThreshold"`
	HttpGet          *WorkloadGroupSpecProbeHttpGet `field:"optional" json:"httpGet" yaml:"httpGet"`
	// Number of seconds after the container has started before readiness probes are initiated.
	InitialDelaySeconds *float64 `field:"optional" json:"initialDelaySeconds" yaml:"initialDelaySeconds"`
	// How often (in seconds) to perform the probe.
	PeriodSeconds *float64 `field:"optional" json:"periodSeconds" yaml:"periodSeconds"`
	// Minimum consecutive successes for the probe to be considered successful after having failed.
	SuccessThreshold *float64 `field:"optional" json:"successThreshold" yaml:"successThreshold"`
	// Health is determined by if the proxy is able to connect.
	TcpSocket *WorkloadGroupSpecProbeTcpSocket `field:"optional" json:"tcpSocket" yaml:"tcpSocket"`
	// Number of seconds after which the probe times out.
	TimeoutSeconds *float64 `field:"optional" json:"timeoutSeconds" yaml:"timeoutSeconds"`
}

// Health is determined by how the command that is executed exited.
type WorkloadGroupSpecProbeExec struct {
	// Command to run.
	Command *[]*string `field:"optional" json:"command" yaml:"command"`
}

type WorkloadGroupSpecProbeHttpGet struct {
	// Host name to connect to, defaults to the pod IP.
	Host *string `field:"optional" json:"host" yaml:"host"`
	// Headers the proxy will pass on to make the request.
	HttpHeaders *[]*WorkloadGroupSpecProbeHttpGetHttpHeaders `field:"optional" json:"httpHeaders" yaml:"httpHeaders"`
	// Path to access on the HTTP server.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Port on which the endpoint lives.
	Port   *float64 `field:"optional" json:"port" yaml:"port"`
	Scheme *string  `field:"optional" json:"scheme" yaml:"scheme"`
}

type WorkloadGroupSpecProbeHttpGetHttpHeaders struct {
	Name  *string `field:"optional" json:"name" yaml:"name"`
	Value *string `field:"optional" json:"value" yaml:"value"`
}

// Health is determined by if the proxy is able to connect.
type WorkloadGroupSpecProbeTcpSocket struct {
	Host *string  `field:"optional" json:"host" yaml:"host"`
	Port *float64 `field:"optional" json:"port" yaml:"port"`
}

// Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
type WorkloadGroupSpecTemplate struct {
	Address *string `field:"optional" json:"address" yaml:"address"`
	// One or more labels associated with the endpoint.
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
	// The locality associated with the endpoint.
	Locality *string `field:"optional" json:"locality" yaml:"locality"`
	Network  *string `field:"optional" json:"network" yaml:"network"`
	// Set of ports associated with the endpoint.
	Ports          *map[string]*float64 `field:"optional" json:"ports" yaml:"ports"`
	ServiceAccount *string              `field:"optional" json:"serviceAccount" yaml:"serviceAccount"`
	// The load balancing weight associated with the endpoint.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}

type WorkloadGroupV1Beta1 interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for WorkloadGroupV1Beta1
type jsiiProxy_WorkloadGroupV1Beta1 struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_WorkloadGroupV1Beta1) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroupV1Beta1) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroupV1Beta1) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroupV1Beta1) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroupV1Beta1) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroupV1Beta1) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_WorkloadGroupV1Beta1) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

// Defines a "WorkloadGroupV1Beta1" API object.
func NewWorkloadGroupV1Beta1(scope constructs.Construct, id *string, props *WorkloadGroupV1Beta1Props) WorkloadGroupV1Beta1 {
	_init_.Initialize()

	j := jsiiProxy_WorkloadGroupV1Beta1{}

	_jsii_.Create(
		"networkingistioio.WorkloadGroupV1Beta1",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "WorkloadGroupV1Beta1" API object.
func NewWorkloadGroupV1Beta1_Override(w WorkloadGroupV1Beta1, scope constructs.Construct, id *string, props *WorkloadGroupV1Beta1Props) {
	_init_.Initialize()

	_jsii_.Create(
		"networkingistioio.WorkloadGroupV1Beta1",
		[]interface{}{scope, id, props},
		w,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func WorkloadGroupV1Beta1_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadGroupV1Beta1",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "WorkloadGroupV1Beta1".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func WorkloadGroupV1Beta1_Manifest(props *WorkloadGroupV1Beta1Props) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadGroupV1Beta1",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func WorkloadGroupV1Beta1_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"networkingistioio.WorkloadGroupV1Beta1",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func WorkloadGroupV1Beta1_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"networkingistioio.WorkloadGroupV1Beta1",
		"GVK",
		&returns,
	)
	return returns
}

func (w *jsiiProxy_WorkloadGroupV1Beta1) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		w,
		"addDependency",
		args,
	)
}

func (w *jsiiProxy_WorkloadGroupV1Beta1) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		w,
		"addJsonPatch",
		args,
	)
}

func (w *jsiiProxy_WorkloadGroupV1Beta1) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		w,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (w *jsiiProxy_WorkloadGroupV1Beta1) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		w,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

type WorkloadGroupV1Beta1Props struct {
	Metadata *cdk8s.ApiObjectMetadata  `field:"optional" json:"metadata" yaml:"metadata"`
	Spec     *WorkloadGroupV1Beta1Spec `field:"optional" json:"spec" yaml:"spec"`
}

type WorkloadGroupV1Beta1Spec struct {
	// Metadata that will be used for all corresponding `WorkloadEntries`.
	Metadata *WorkloadGroupV1Beta1SpecMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
	Probe *WorkloadGroupV1Beta1SpecProbe `field:"optional" json:"probe" yaml:"probe"`
	// Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
	Template *WorkloadGroupV1Beta1SpecTemplate `field:"optional" json:"template" yaml:"template"`
}

// Metadata that will be used for all corresponding `WorkloadEntries`.
type WorkloadGroupV1Beta1SpecMetadata struct {
	Annotations *map[string]*string `field:"optional" json:"annotations" yaml:"annotations"`
	Labels      *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
}

// `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
type WorkloadGroupV1Beta1SpecProbe struct {
	// Health is determined by how the command that is executed exited.
	Exec *WorkloadGroupV1Beta1SpecProbeExec `field:"optional" json:"exec" yaml:"exec"`
	// Minimum consecutive failures for the probe to be considered failed after having succeeded.
	FailureThreshold *float64                              `field:"optional" json:"failureThreshold" yaml:"failureThreshold"`
	HttpGet          *WorkloadGroupV1Beta1SpecProbeHttpGet `field:"optional" json:"httpGet" yaml:"httpGet"`
	// Number of seconds after the container has started before readiness probes are initiated.
	InitialDelaySeconds *float64 `field:"optional" json:"initialDelaySeconds" yaml:"initialDelaySeconds"`
	// How often (in seconds) to perform the probe.
	PeriodSeconds *float64 `field:"optional" json:"periodSeconds" yaml:"periodSeconds"`
	// Minimum consecutive successes for the probe to be considered successful after having failed.
	SuccessThreshold *float64 `field:"optional" json:"successThreshold" yaml:"successThreshold"`
	// Health is determined by if the proxy is able to connect.
	TcpSocket *WorkloadGroupV1Beta1SpecProbeTcpSocket `field:"optional" json:"tcpSocket" yaml:"tcpSocket"`
	// Number of seconds after which the probe times out.
	TimeoutSeconds *float64 `field:"optional" json:"timeoutSeconds" yaml:"timeoutSeconds"`
}

// Health is determined by how the command that is executed exited.
type WorkloadGroupV1Beta1SpecProbeExec struct {
	// Command to run.
	Command *[]*string `field:"optional" json:"command" yaml:"command"`
}

type WorkloadGroupV1Beta1SpecProbeHttpGet struct {
	// Host name to connect to, defaults to the pod IP.
	Host *string `field:"optional" json:"host" yaml:"host"`
	// Headers the proxy will pass on to make the request.
	HttpHeaders *[]*WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders `field:"optional" json:"httpHeaders" yaml:"httpHeaders"`
	// Path to access on the HTTP server.
	Path *string `field:"optional" json:"path" yaml:"path"`
	// Port on which the endpoint lives.
	Port   *float64 `field:"optional" json:"port" yaml:"port"`
	Scheme *string  `field:"optional" json:"scheme" yaml:"scheme"`
}

type WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders struct {
	Name  *string `field:"optional" json:"name" yaml:"name"`
	Value *string `field:"optional" json:"value" yaml:"value"`
}

// Health is determined by if the proxy is able to connect.
type WorkloadGroupV1Beta1SpecProbeTcpSocket struct {
	Host *string  `field:"optional" json:"host" yaml:"host"`
	Port *float64 `field:"optional" json:"port" yaml:"port"`
}

// Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
type WorkloadGroupV1Beta1SpecTemplate struct {
	Address *string `field:"optional" json:"address" yaml:"address"`
	// One or more labels associated with the endpoint.
	Labels *map[string]*string `field:"optional" json:"labels" yaml:"labels"`
	// The locality associated with the endpoint.
	Locality *string `field:"optional" json:"locality" yaml:"locality"`
	Network  *string `field:"optional" json:"network" yaml:"network"`
	// Set of ports associated with the endpoint.
	Ports          *map[string]*float64 `field:"optional" json:"ports" yaml:"ports"`
	ServiceAccount *string              `field:"optional" json:"serviceAccount" yaml:"serviceAccount"`
	// The load balancing weight associated with the endpoint.
	Weight *float64 `field:"optional" json:"weight" yaml:"weight"`
}
